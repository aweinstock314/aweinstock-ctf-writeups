#!/usr/bin/env python
# import complex # wget https://raw.githubusercontent.com/Z3Prover/z3/master/examples/python/complex/complex.py
from scipy.linalg import block_diag
import IPython
import cmath
import itertools
import math
import numpy as np
import struct
import sys

i = np.array([[1, 0], [0, 1]], dtype=complex)
x = np.array([[0, 1], [1, 0]])
y = np.array([[0, -1j], [1j, 0]])
z = np.array([[1, 0], [0, -1]])
h = (1.0/math.sqrt(2)) * np.array([[1,1],[1,-1]])
r = np.array([[1, 0], [0, 1j]])
p = lambda angle: np.array([[1, 0], [0, cmath.exp(angle*1j)]])

P = np.array([[1, 0, 0, 0],
              [0, 0, 1, 0],
              [0, 1, 0, 0],
              [0, 0, 0, 1]])
Q = lambda w: P if w else np.eye(4)
Mprime = lambda m, c: i if c else m
N = lambda m, c: block_diag(Mprime(m,c), m) 

# Gates
G_I = 0 # Identity
G_X = 1 # Pauli X-gate
G_Y = 2 # Pauli Y-gate
G_Z = 3 # Pauli Z-gate
G_H = 4 # Hadamard gate
G_R = 5 # R2 gate: rotate phase by 90 degrees
G_P = 6 # Rotate phase by an angle specified in radians
G_M = 7 # Measure in standard (Z) basis, and if 1, self-destruct

STATE0 = np.array([1, 0, 0, 0])

def complex2probability(c):
    return float(abs(c)**2)


def apply_gate(state, m, wire, control):
    '''
>>> apply_gate(STATE0, h, False, False)
array([[ 0.70710678+0.j],
       [ 0.70710678+0.j],
       [ 0.00000000+0.j],
       [ 0.00000000+0.j]])
>>> a = apply_gate(STATE0, h, True, False)
>>> a
array([[ 0.70710678+0.j],
       [ 0.00000000+0.j],
       [ 0.70710678+0.j],
       [ 0.00000000+0.j]])
>>> for (i, j) in itertools.product([0,1],[0,1]):
...     print apply_gate(a, h, i, j)
...     
[[ 0.5+0.j]
 [ 0.5+0.j]
 [ 0.5+0.j]
 [ 0.5+0.j]]
[[ 0.70710678+0.j]
 [ 0.00000000+0.j]
 [ 0.50000000+0.j]
 [ 0.50000000+0.j]]
[[ 1.+0.j]
 [ 0.+0.j]
 [ 0.+0.j]
 [ 0.+0.j]]
[[ 0.70710678+0.j]
 [ 0.00000000+0.j]
 [ 0.70710678+0.j]
 [ 0.00000000+0.j]]
    '''
#>>> b = apply_gate(a, h, False, True)
#>>> b
#array([[ 0.70710678],
#       [ 0.        ],
#       [ 0.5       ],
#       [ 0.5       ]])
    '''
    if control:
        m0 = i
        m1 = m
    else:
        m0 = m1 = m
    if wire:
        s0 = np.vstack([[state[0]],[state[2]]])
        s1 = np.vstack([[state[1]],[state[3]]])
    else:
        s0 = np.vstack([[state[0]],[state[1]]])
        s1 = np.vstack([[state[2]],[state[3]]])
    r0 = m0.dot(s0)
    r1 = m1.dot(s1)
    if wire:
        return np.vstack([[r0[0]],[r1[0]],[r0[1]],[r1[1]]])
    else:
        return np.vstack([r0, r1])
    '''
    m = np.array(m, dtype=complex)
    q = Q(wire)
    n = N(m, control)
    #print('N is: %r' % n)
    state = np.array(state).reshape((4,1))
    return q.dot(n).dot(q).dot(state).reshape((4,1))

def measure_wire(state, wire):
    '''
>>> measure_wire(STATE0, 0)
(array([[ 1.],
       [ 0.],
       [ 0.],
       [ 0.]]), 1.0)
>>> a = apply_gate(STATE0, h, True, False)
>>> measure_wire(a, 0)
(array([[ 0.70710678+0.j],
       [ 0.00000000+0.j],
       [ 0.70710678+0.j],
       [ 0.00000000+0.j]]), 0.9999999999999998)
>>> measure_wire(a, 1)
(array([[ 1.+0.j],
       [ 0.+0.j],
       [ 0.+0.j],
       [ 0.+0.j]]), 0.4999999999999999)
    '''
    p = complex2probability(state[0])
    p += complex2probability(state[1 if wire else 2])
    #print("Exploding with probability %f" % (p,))
    if wire:
        middle = np.vstack([state[1]/math.sqrt(p), 0])
    else:
        middle = np.vstack([0, state[2]/math.sqrt(p)])
    return (np.vstack([
        state[0] / math.sqrt(p),
        middle,
        0
    ]), p)

def emit_gate(gate, p=None):
    gatebyte = 0
    if gate['wire']:
        gatebyte |= 0x80
    if gate.has_key('type'):
        gatebyte |= 0x70
        if gate.has_key('controlled') and gate['controlled']:
            gatebyte |= 0x08
        gatebyte |= gate['type'] & 0x07
    else:
        assert gate.has_key('input')
        gatebyte |= gate['input'] & 0x7f
    if gate.has_key('type') and gate['type'] == G_P:
        assert gate.has_key('angle')
        if p:
            p.send(struct.pack("B", gatebyte))
            p.send(struct.pack("d", gate['angle']))
        #return (struct.pack("B", gatebyte), struct.pack("d", gate['angle']))
        return struct.pack("Bd", gatebyte, gate['angle'])
    else:
        if p:
            p.send(struct.pack("B", gatebyte))
        return struct.pack("B", gatebyte)

def emit_circuit(gates, p=None):
    '''
>>> import math
>>> emit_circuit([{'type': G_X, 'wire': 0}]).encode('hex')
'000171'
>>> emit_circuit([{'type': G_Y, 'wire': 1, 'controlled': True}]).encode('hex')
'0001fa'
>>> emit_circuit([{'input': 42, 'wire': 0}]).encode('hex')
'00012a'
>>> emit_circuit([{'input': 42, 'wire': 0}, {'type': G_P, 'wire': 0, 'angle': math.pi}]).encode('hex')
'00022a7600000000000000182d4454fb210940'
    '''
    payload = ''
    # num_gates := uint16(command[1]) + 256*uint16(command[0]) // looks big-endian
    tmp = struct.pack(">H", len(gates))
    payload += tmp
    if p:
        p.send(tmp)
    for gate in gates:
        payload += emit_gate(gate, p)
    return payload

def eval_gate(gate, state, bombs, prints=False):
    wire = gate['wire']
    if gate.has_key('type'):
        m = {
            G_I: i, # Identity
            G_X: x, # Pauli X-gate
            G_Y: y, # Pauli Y-gate
            G_Z: z, # Pauli Z-gate
            G_H: h, # Hadamard gate
            G_R: r, # R2 gate: rotate phase by 90 degrees
            G_P: p, # Rotate phase by an angle specified in radians
            G_M: None, # Measure in standard (Z) basis, and if 1, self-destruct
        }[gate['type']]
        if gate['type'] == G_P:
            m = m(gate['angle'])
        if prints:
            print('Matrix: %r' % (m,))
        controlled = gate.get('controlled', 0)
        return (apply_gate(state, m, wire, controlled), 0)
    else:
        assert gate.has_key('input')
        if bombs[gate['input']]:
            if prints:
                print('Bomb present')
            return measure_wire(state, wire)
        else:
            if prints:
                print('Bomb absent')
            return (apply_gate(state, i, wire, 0), 0)

def eval_circuit(circuit, bombs=None, prints=False):
    state = STATE0
    if bombs is None:
        bombs = np.random.randint(0, 2, (0x70,))
    success_probability = 1.0
    for (i, gate) in enumerate(circuit):
        if prints:
            print('State %d: %r; evaluating %r' % (i, state, gate))
        state, failure_prob = eval_gate(gate, state, bombs, prints)
        success_probability *= (1.0-failure_prob)
    if prints:
        print('Ending state: %r' % (state,))
        print('Ending success probability: %f' % (success_probability,))
        print('Ending probabilities: %r' % (map(complex2probability, state),))
    return (success_probability, state)

# eval_circuit([{'type': G_H, 'wire': 1}, {'input': 0, 'wire': 1}])
'''
In [29]: eval_circuit([{'type': G_H, 'wire': 1}, {'type': G_H, 'wire': 0, 'controlled': 1}, {'input': 0, 'wire': 1}], [1])
State 0: array([1, 0, 0, 0]); evaluating {'wire': 1, 'type': 4}
State 1: array([[ 0.70710678],
       [ 0.        ],
       [ 0.70710678],
       [ 0.        ]]); evaluating {'controlled': 1, 'wire': 0, 'type': 4}
State 2: array([[ 0.70710678],
       [ 0.        ],
       [ 0.5       ],
       [ 0.5       ]]); evaluating {'input': 0, 'wire': 1}
Bomb present
Exploding with probability 0.500000
Ending state: array([[ 1.],
       [ 0.],
       [ 0.],
       [ 0.]])
Ending probabilities: [1.0, 0.0, 0.0, 0.0]
'''

'''
In [4]: p(math.pi/4).dot(x)
Out[4]: 
array([[ 0.00000000+0.j        ,  1.00000000+0.j        ],
       [ 0.70710678+0.70710678j,  0.00000000+0.j        ]])

In [5]: p(math.pi/4).dot(x).dot([1,0])
Out[5]: array([ 0.00000000+0.j        ,  0.70710678+0.70710678j])

In [6]: x.dot(p(math.pi/4))
Out[6]: 
array([[ 0.00000000+0.j        ,  0.70710678+0.70710678j],
       [ 1.00000000+0.j        ,  0.00000000+0.j        ]])

In [7]: x.dot(p(math.pi/4)).dot([1,0])
Out[7]: array([ 0.+0.j,  1.+0.j])
'''

def brute_gates(state=[1, 10, 100, 1000]):
    for (wire, control) in itertools.product([0,1],[0,1]):
        print('wire: %d, control: %d' % (wire, control))
        for (s, m) in [('i',i),('x',x),('y',y),('z',z),('h',h),('r',r),('p4', p(math.pi/4))]:
            print('%s: %r' % (s, apply_gate(state, m, wire, control),))

def cons2list(cdr):
    xs = []
    while cdr:
        car, cdr = cdr
        xs.append(car)
    return xs

def brute_evaluator(path=(), depth=3, epsilon=0.1, appendbomb=True):
    if depth > 0:
        for (wire, control) in itertools.product([0,1],[0,1]):
            for possible_matrix in [G_I, G_X, G_Y, G_Z, G_H, G_R, G_P]:
                gate = {'wire': wire, 'control': control, 'type': possible_matrix}
                n = 32
                for angle in [2*i*math.pi/n for i in range(n)]:
                    gate['angle'] = angle
                    newpath = (dict(gate.items()), path)
                    brute_evaluator(newpath, depth-1)
                    if possible_matrix != G_P:
                        break
    else:
        if appendbomb:
            #circuit = circuit + [{'input': 0, 'wire': 0}]
            path = ({'input': 0, 'wire': 0}, path)
        circuit = list(reversed(cons2list(path)))
        (notbomb, state) = eval_circuit(circuit, [1])
        if notbomb > 0.55 and notbomb < 1.0:
            print("Circuit: %r"  % (circuit,))
            print("notbomb probability: %r" % (notbomb,))
            print("final state: %r" % (state,))
            print("-----")
'''
((2.220446049250313e-16, array([[ 0.70710678+0.j],
       [ 0.00000000+0.j],
       [ 0.70710678+0.j],
       [ 0.00000000+0.j]])), [{'control': 0, 'type': 4, 'wire': 1, 'angle': 0.0}, {'control': 0, 'type': 0, 'wire': 0, 'angle': 0.0}, {'control': 0, 'type': 0, 'wire': 0, 'angle': 0.0}, {'control': 0, 'type': 0, 'wire': 0, 'angle': 0.0}, {'control': 0, 'type': 0, 'wire': 0, 'angle': 0.0}])
'''
'''
Circuit: [{'control': 0, 'type': 4, 'wire': 0, 'angle': 0.0}, {'control': 1, 'type': 6, 'wire': 0, 'angle': 2.945243112740431}, {'control': 0, 'type': 4, 'wire': 0, 'angle': 0.0}, {'control': 0, 'type': 0, 'wire': 0, 'angle': 0.0}, {'control': 0, 'type': 0, 'wire': 0, 'angle': 0.0}]
notbomb probability: 0.9903926402016152
final state: array([[ 0.09801714+0.99518473j],
       [ 0.00000000+0.j        ],
       [ 0.00000000+0.j        ],
       [ 0.00000000+0.j        ]])
'''
'''
Circuit: [{'control': 0, 'type': 4, 'wire': 0, 'angle': 0.0}, {'control': 1, 'type': 6, 'wire': 0, 'angle': 2.945243112740431}, {'control': 0, 'type': 4, 'wire': 0, 'angle': 0.0}, {'input': 0, 'wire': 0}]
notbomb probability: 0.9903926402016152
final state: array([[ 0.09801714+0.99518473j],
       [ 0.00000000+0.j        ],
       [ 0.00000000+0.j        ],
       [ 0.00000000+0.j        ]])
'''

circ = [{'control': 0, 'type': 4, 'wire': 0, 'angle': 0.0}, {'control': 1, 'type': 6, 'wire': 0, 'angle': 2.945243112740431}, {'control': 0, 'type': 4, 'wire': 0, 'angle': 0.0}, {'input': 0, 'wire': 0}]

def interactionfreemeasurement(idx):
    #possible_bomb = {'input': idx}
    return [{'control': 0, 'type': 4, 'wire': 0, 'angle': 0.0},
            {'control': 1, 'type': 6, 'wire': 0, 'angle': 2.945243112740431},
            {'control': 0, 'type': 4, 'wire': 0, 'angle': 0.0}] + [
            {'input': idx, 'wire': 0}]
            #]

def ifm_postcompetition(idx, iters=1000, phi=0.001):
    '''
    Constants here are from https://hxp.io/blog/30/

    It seems like the error I made was inverting the 
    probability in measure_wire, which means I chose a phase 
    that maximized the probability of bomb exploding (rather 
    than minimized)
    '''
    return iters*([{'control': 0, 'type': 4, 'wire': 0, 'angle': 0.0},
            {'control': 1, 'type': 6, 'wire': 0, 'angle': phi},
            {'control': 0, 'type': 4, 'wire': 0, 'angle': 0.0}] + [
            {'input': idx, 'wire': 0}])

if __name__ == '__main__':
    #IPython.embed()

    from pwn import *
    p = remote('localhost', 8001) if '--live' not in sys.argv else remote('54.202.194.91', 65535)

    results = []
    for idx in range(0x70):
    #for idx in [0]:
        #tmp = emit_circuit(interactionfreemeasurement(idx), p)
        tmp = emit_circuit(ifm_postcompetition(idx), p)
        #print('sending %r' % tmp)
        #p.send(tmp)
        result = p.recv(1)
        print('results[%d] = %r' % (idx, result))
        results.append(result)

    print(results)

    p.interactive()
