/*!
```cargo
[dependencies]
goblin = "0.2"
anyhow = "1.0"
faerie = "0.15"
target-lexicon = "0.10"
```
*/
extern crate faerie;
extern crate goblin;
extern crate target_lexicon;
use goblin::elf::{Elf, dynamic::*};
use goblin::elf64::{
    header::{self, Header},
    program_header::{self as Phdr, ProgramHeader},
    section_header::{self as Shdr, SectionHeader},
    dynamic,
    };
use std::{io, mem};
use std::io::Write;
use std::collections::BTreeMap;
use std::fs::{self, File};
use std::str::FromStr;
use faerie::{ArtifactBuilder, Decl, Link, SectionKind};
use std::collections::BTreeSet;

/*fn main_old() -> Result<(), anyhow::Error> {
    //let mut elf = ArtifactBuilder::new(target_lexicon::triple!("x86_64-linux-gnu")).library(true).finish();
    let mut elf = ArtifactBuilder::new(target_lexicon::triple!("x86_64-unknown-unknown-unknown-elf")).library(true).finish();
    elf.declare(".init", Decl::section(SectionKind::Data))?;
    elf.declare("main", Decl::function().global())?;
    //let mut symbols = BTreeMap::new();
    //symbols.insert("main".into(), 0);
    //elf.define_with_symbols(".init", vec![0xeb, 0xfe], symbols)?;
    elf.define(".init", vec![0xeb, 0xfe])?;
    elf.define("main", vec![0xeb, 0xfe])?;
    //elf.link(Link { from: ".init", to: "main", at: 0})?;
    //elf.write(File::create("libgolf.so")?)?;
    let mut elfbytes: Vec<u8> = elf.emit()?;
    //let mut elf2 = Elf::parse(&elfbytes)?;
    println!("elfbytes {:?}", elfbytes);
    {
        let mut header: &mut Header = unsafe { &mut *(elfbytes.as_mut_ptr() as *mut Header) };
        println!("header {:?}", header);
        header.e_type = header::ET_DYN | header::ET_EXEC;
        println!("header {:?}", header);
        for i in 0..(header.e_shnum as usize) {
            let mut shdr: &mut SectionHeader = unsafe { &mut *(elfbytes.as_mut_ptr().offset(header.e_shoff as isize).offset(header.e_shentsize as isize*i as isize) as *mut SectionHeader) };
            println!("shdr {}: {:?}", i, shdr);
        }
    
    }
    println!("elfbytes {:?}", elfbytes);
    let mut file = File::create("libgolf.so")?;
    file.write(&elfbytes)?;
    
    Ok(())
}*/

fn main() -> Result<(), anyhow::Error> {
    /*let bytes_from_c = fs::read("./a.out")?;
    let from_c = Elf::parse(&bytes_from_c)?;
    println!("{:#?}", from_c);*/
    let e_ident = [0x7f, b'E', b'L', b'F', header::ELFCLASS64, header::ELFDATA2LSB, header::EV_CURRENT, header::ELFOSABI_NONE, 0, 0, 0, 0, 0, 0, 0, 0];
    let binsh_offset = 0x18;
    //let elf_size = 0x101-26-6-1;
    //let dyn_offset = 0xe0-26-6-1;
    let elf_size = 0xd1-13;
    let dyn_offset = 0xb0-13;
    let shellcode_offset = 0xb0-6-6;
    let phdr_offset = 0x40-6;
    let mut elfbytes = vec![0; elf_size];
    let header: &mut Header = unsafe { &mut *(elfbytes.as_mut_ptr() as *mut Header) };
    *header = Header {
        e_ident,
        e_type: header::ET_DYN,
        e_machine: header::EM_X86_64,
        e_version: header::EV_CURRENT as _,
        e_entry: 0,
        e_phoff: phdr_offset,
        e_shoff: 0,
        e_flags: 0,
        e_ehsize: mem::size_of::<Header>() as _,
        e_phentsize: mem::size_of::<ProgramHeader>() as _,
        e_phnum: 2,
        e_shentsize: mem::size_of::<SectionHeader>() as _,
        e_shnum: 0,
        e_shstrndx: 0,
    };
    println!("header: {:?}", header);
    let phdr: &mut ProgramHeader = unsafe { &mut *(elfbytes.as_mut_ptr().offset(phdr_offset as _) as *mut ProgramHeader) };
    *phdr = ProgramHeader {
        p_type: Phdr::PT_LOAD,
        p_flags: Phdr::PF_R | Phdr::PF_W | Phdr::PF_X,
        p_offset: 0,
        p_vaddr: 0x41410000,
        p_paddr: 0x41410000,
        p_filesz: elf_size as _,
        p_memsz: elf_size as _,
        p_align: 0x1000,
    };
    println!("phdr: {:?}", phdr);
    let phdr2: &mut ProgramHeader = unsafe { &mut *(elfbytes.as_mut_ptr().offset(phdr_offset as _).offset(mem::size_of::<ProgramHeader>() as _) as *mut ProgramHeader) };
    *phdr2 = ProgramHeader {
        p_type: Phdr::PT_DYNAMIC,
        p_flags: Phdr::PF_R,
        p_offset: 400,
        p_vaddr: 0x41410000 + dyn_offset,
        p_paddr: 0,
        p_filesz: mem::size_of::<dynamic::Dyn>() as _,
        p_memsz: mem::size_of::<dynamic::Dyn>() as _,
        p_align: 8,
    };
    println!("phdr2: {:?}", phdr2);

    let do_the_dynamic = |elfbytes: &mut Vec<u8>, blacklist: &mut BTreeSet<usize>, actual_shellcode_offset: usize| {
        let dynamic = vec![
            // https://docs.oracle.com/cd/E19683-01/817-3677/chapter6-42444/index.html
            //dynamic::Dyn { d_tag: DT_HASH, d_val: 0xdeadbeefdeadbeef },
            dynamic::Dyn { d_tag: DT_INIT, d_val: 0x41410000+(actual_shellcode_offset as u64) },
            dynamic::Dyn { d_tag: DT_STRTAB, d_val: 0 },
            dynamic::Dyn { d_tag: DT_SYMTAB, d_val: 0 },
            //dynamic::Dyn { d_tag: DT_STRSZ, d_val: 0 },
            //dynamic::Dyn { d_tag: DT_SYMENT, d_val: 0 },
            dynamic::Dyn { d_tag: DT_NULL, d_val: 0 },
        ];
        /*let mut dynamic_raw: &mut [dynamic::Dyn] = unsafe { std::slice::from_raw_parts_mut(elfbytes.as_mut_ptr().offset(dyn_offset as _) as *mut dynamic::Dyn, dynamic.len()) };
        for (x, y) in dynamic.into_iter().zip(dynamic_raw.iter_mut()) { *y = x; }*/
        for (i, x) in dynamic.iter().enumerate() {
            let stride = 4;
            let mult = if x.d_tag == DT_INIT || x.d_tag == DT_NULL { 2*stride } else { stride };
            let lo = i*stride;
            let hi = lo + mult;
            for j in lo..hi {
                blacklist.insert(dyn_offset as usize+j);
            }
        }
        for (i, x) in unsafe { std::slice::from_raw_parts(dynamic.as_ptr() as *const u8, dynamic.len() * mem::size_of::<dynamic::Dyn>()) }.iter().enumerate() {
            if *x != 0 {
                elfbytes[(dyn_offset as usize)+i] = *x;
            }
        }
    };
    let mut blacklist = BTreeSet::<usize>::new();
    do_the_dynamic(&mut elfbytes, &mut blacklist, shellcode_offset);

    for (i, x) in b"/bin/sh".iter().enumerate() {
        elfbytes[binsh_offset+i] = *x;
    }


/*
   0:   48 ba 2f 62 69 6e 2f    movabs $0x68732f6e69622f,%rdx
   7:   73 68 00
   a:   48 83 e8 10             sub    $0x10,%rax
   e:   48 89 10                mov    %rdx,(%rax)
  11:   48 89 c7                mov    %rax,%rdi
  14:   48 31 d2                xor    %rdx,%rdx
  17:   48 83 e8 08             sub    $0x8,%rax
  1b:   48 89 10                mov    %rdx,(%rax)
  1e:   48 83 e8 08             sub    $0x8,%rax
  22:   48 89 38                mov    %rdi,(%rax)
  25:   48 89 c6                mov    %rax,%rsi
  28:   48 31 c0                xor    %rax,%rax
  2b:   b0 3b                   mov    $0x3b,%al
  2d:   0f 05                   syscall
---
b"\x48\xba\x2f\x62\x69\x6e\x2f\x73\x68\x00\x48\x83\xe8\x10\x48\x89\x10\x48\x89\xc7\x48\x31\xd2\x48\x83\xe8\x08\x48\x89\x10\x48\x83\xe8\x08\x48\x89\x38\x48\x89\xc6\x48\x31\xc0\xb0\x3b\x0f\x05"
---
   0:   2c 92                   sub    $0x92,%al
   2:   48 89 10                mov    %rdx,(%rax)
   5:   48 89 c7                mov    %rax,%rdi
   8:   48 31 d2                xor    %rdx,%rdx
   b:   2c 08                   sub    $0x8,%al
   d:   48 89 10                mov    %rdx,(%rax)
  10:   2c 08                   sub    $0x8,%al
  12:   48 89 38                mov    %rdi,(%rax)
  15:   48 89 c6                mov    %rax,%rsi
  18:   48 31 c0                xor    %rax,%rax
  1b:   b0 3b                   mov    $0x3b,%al
  1d:   0f 05                   syscall
---
b"\x2c\x92\x48\x89\x10\x48\x89\xc7\x48\x31\xd2\x2c\x08\x48\x89\x10\x2c\x08\x48\x89\x38\x48\x89\xc6\x48\x31\xc0\xb0\x3b\x0f\x05";
---
   0:   2c 92                   sub    $0x92,%al
   2:   48 89 c7                mov    %rax,%rdi
   5:   48 31 d2                xor    %rdx,%rdx
   8:   2c 08                   sub    $0x8,%al
   a:   48 89 10                mov    %rdx,(%rax)
   d:   2c 08                   sub    $0x8,%al
   f:   48 89 38                mov    %rdi,(%rax)
  12:   48 89 c6                mov    %rax,%rsi
  15:   48 31 c0                xor    %rax,%rax
  18:   b0 3b                   mov    $0x3b,%al
  1a:   0f 05                   syscall
---
b"\x2c\x92\x48\x89\xc7\x48\x31\xd2\x2c\x08\x48\x89\x10\x2c\x08\x48\x89\x38\x48\x89\xc6\x48\x31\xc0\xb0\x3b\x0f\x05"
---
[b"\x2c\x92", b"\x48\x89\xc7", b"\x48\x31\xd2", b"\x2c\x08", b"\x48\x89\x10", b"\x2c\x08", b"\x48\x89\x38", b"\x48\x89\xc6", b"\x48\x31\xc0", b"\xb0\x3b", b"\x0f\x05"]
*/
    //let shellcode = b"\xeb\xfe";
    //let shellcode = b"\xff\x34\x25\x2f\x73\x68\x00\xff\x34\x25\x2f\x62\x69\x6e\x48\x89\xe7\x48\x31\xf6\x48\x31\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xeb\xfe";
    //let shellcode = b"\x48\xba\x2f\x62\x69\x6e\x2f\x73\x68\x00\x48\x83\xe8\x10\x48\x89\x10\x48\x89\xc7\x48\x31\xf6\x48\x31\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xeb\xfe";
    //let shellcode = b"\x48\xba\x2f\x62\x69\x6e\x2f\x73\x68\x00\x48\x83\xe8\x10\x48\x89\x10\x48\x89\xc7\x48\x83\xe8\x10\x48\x89\x38\x48\x89\xc6\x48\x31\xd2\x48\x31\xc0\xb0\x3b\x0f\x05";
    //let shellcode = b"\x48\xba\x2f\x62\x69\x6e\x2f\x73\x68\x00\x48\x83\xe8\x10\x48\x89\x10\x48\x31\xd2\x48\x83\xe8\x10\x48\x89\x10\x48\x89\xc7\x48\x83\xe8\x10\x48\x89\x38\x48\x89\xc6\x48\x31\xc0\xb0\x3b\x0f\x05\xeb\xfe";
    //let shellcode = b"\x48\xba\x2f\x62\x69\x6e\x2f\x73\x68\x00\x48\x83\xe8\x10\x48\x89\x10\x48\x89\xc7\x48\x31\xd2\x48\x83\xe8\x10\x48\x89\x10\x48\x83\xe8\x10\x48\x89\x38\x48\x89\xc6\x48\x31\xc0\xb0\x3b\x0f\x05";
    //let shellcode = b"\x48\xba\x2f\x62\x69\x6e\x2f\x73\x68\x00\x48\x83\xe8\x10\x48\x89\x10\x48\x89\xc7\x48\x31\xd2\x48\x83\xe8\x08\x48\x89\x10\x48\x83\xe8\x08\x48\x89\x38\x48\x89\xc6\x48\x31\xc0\xb0\x3b\x0f\x05";
    //let shellcode = b"\x2c\x92\x48\x89\x10\x48\x89\xc7\x48\x31\xd2\x2c\x08\x48\x89\x10\x2c\x08\x48\x89\x38\x48\x89\xc6\x48\x31\xc0\xb0\x3b\x0f\x05";
    /*let shellcode = b"\x2c\x92\x48\x89\xc7\x48\x31\xd2\x2c\x08\x48\x89\x10\x2c\x08\x48\x89\x38\x48\x89\xc6\x48\x31\xc0\xb0\x3b\x0f\x05";

    for (i, x) in shellcode.iter().enumerate() {
        elfbytes[shellcode_offset+i] = *x;
    }*/
    let shellcodes: &[&[u8]] = &[&*b"\x2c\x92", &*b"\x48\x89\xc7", &*b"\x48\x31\xd2", &*b"\x2c\x08", &*b"\x48\x89\x10", &*b"\x2c\x08", &*b"\x48\x89\x38", &*b"\x48\x89\xc6", &*b"\x48\x31\xc0", &*b"\xb0\x3b", &*b"\x0f\x05"];
    //let shellcodes: &[&[u8]] = &[&*b"\x2c\x92", &*b"\x48\x89\xc7", &*b"\x48\x31\xd2", &*b"\x2c\x08", &*b"\x48\x89\x10", &*b"\x2c\x08", &*b"\x48\x89\x38", &*b"\x48\x89\xc6", &*b"\x48\x31\xc0", &*b"\xb0\x3b", &*b"\xeb\xfe"];
    println!("sc lens {:?}", shellcodes.iter().map(|x| x.len()).collect::<Vec<usize>>());
/*
>>> x = [2, 3, 3, 2, 3, 2, 3, 3, 3, 2, 2]
>>> sum(x)
28
>>> [sum(x[:i+1]) for i in range(len(x))]
[2, 5, 8, 10, 13, 15, 18, 21, 24, 26, 28]
*/
    //let mut elf_i: usize = shellcode_offset-0x10;
    let mut elf_i: usize = 0x28;
    let mut actual_shellcode_offset = elf_i;
    let mut sc_i: usize = 0;
    let mut prev_jump_disp = None;
    for i in 0x32..0x40 { blacklist.insert(i); }
    for i in 0x42..0x4c { blacklist.insert(i); }
    for i in 0x50..0x54 { blacklist.insert(i); }
    for i in 0x63..0x70 { blacklist.insert(i); }
    for i in 0x80..0x8a { blacklist.insert(i); }
    for i in 0xa2..0xa4 { blacklist.insert(i); }
    println!("blacklist {:?}", blacklist);
    while sc_i < shellcodes.len() {
        while elfbytes[elf_i] != 0 || blacklist.contains(&elf_i) { elf_i += 1; }
        let mut zeros_start = elf_i;
        while elfbytes[elf_i] == 0 && !blacklist.contains(&elf_i) && elf_i+1 < elfbytes.len() { elf_i += 1; }
        //  aa 00 00 00 00 bb
        // ^zs            ^ei
        println!("zeros between {} and {}", zeros_start, elf_i);
        let num_zeros = elf_i - zeros_start;
        if num_zeros < 2 {
            elf_i += 1;
            continue;
        }
        let sc_start = sc_i;
        let mut sc_bytes = 0;
        let mut jump_needed = if sc_i != shellcodes.len() { 2 } else { 0 };
        while (sc_bytes + jump_needed < num_zeros) && (sc_i < shellcodes.len()) {
            if sc_bytes + shellcodes[sc_i].len() + jump_needed > num_zeros {
                break
            }
            sc_bytes += shellcodes[sc_i].len();
            sc_i += 1;
            jump_needed = if sc_i != shellcodes.len() { 2 } else { 0 };
        }
        println!("sc bytes {} jump needed {} sc_i {}", sc_bytes, jump_needed, sc_i);
        if sc_bytes > 0 {
            if let Some(x) = prev_jump_disp.take() {
                elfbytes[x] = (zeros_start - x - 1) as u8;
                //elfbytes[x] = 00;
            }
            for i in sc_start..sc_i {
                let sc = shellcodes[i];
                elfbytes[zeros_start..zeros_start+sc.len()].copy_from_slice(sc);
                zeros_start += sc.len();
                //  aa 2c 92 00 00 bb
                //          ^zs   ^ei
                if i == 0 {
                    actual_shellcode_offset = zeros_start-2;
                    elfbytes[zeros_start-1] = (zeros_start - binsh_offset - 2) as u8;
                }
            }
            //  aa 2c 92 eb xx bb 00 00
            //                ^ei
            if jump_needed > 0 {
                elfbytes[zeros_start..zeros_start+2].copy_from_slice(b"\xeb\xfe");
                prev_jump_disp = Some(zeros_start+1);
            }
        }
    }
    println!("actual offset: {}", actual_shellcode_offset);
    do_the_dynamic(&mut elfbytes, &mut blacklist, actual_shellcode_offset);

    let mut file = File::create("libgolf2.so")?;
    file.write(&elfbytes)?;
    Ok(())
}
/*
set follow-fork-mode child
r -c 'LD_PRELOAD=./libgolf2.so /bin/true'
*/

/*
at the 288-byte mark:
You made it to level 2: thoughtful! You have 64 bytes left to be hand-crafted. This effort is worthy of 1/2 flags. PCTF{th0ugh_wE_have_cl1mBed_far_we_MusT_St1ll_c0ntinue_oNward}
*/

/*
at the 224-byte mark:
You made it to level 3: hand-crafted! You have 30 bytes left to be flag-worthy. This effort is worthy of 1/2 flags. PCTF{th0ugh_wE_have_cl1mBed_far_we_MusT_St1ll_c0ntinue_oNward}
*/
