from pwn import *
from bendersky_modsqrt import modular_sqrt, legendre_symbol
import prejudiced_functions
import itertools
import gmpy
import os

'''
Understanding of prejudiced so far:
1) we provide n, which is checked after the fact to be the product of two at-least-512-bit primes (not necessarily distinct, so n == p**2 is allowed)
2) the server generates a random number r, and gives us s = (r**2 % n)
3) we need to compute sqrt(s) (TODO: https://en.wikipedia.org/wiki/Quadratic_residue#Composite_modulus claims this is easy if we already have the factors)
4) the server uses our answer to factor n, probably based on https://en.wikipedia.org/wiki/Congruence_of_squares
4a) if they factor n successfully, we "lose" the round
4b) if they don't factor n successfully, we "win" the round
5) we need to win 0.9*42 consecutive rounds for the "easy" flag, and we need to lose 0.9*42 consecutive rounds for the "hard" flag

I think that if we play honestly, the randomness in step 4 whether the square 
root that we chose is has the same "sign" as theirs (i.e. if we reply r, r-ans 
is 0 so they get no information, but if we reply (r^-1 mod pq) (which is also a modular 
square root of s), they learn (p, q)

I think we need ways to choose p and q such that we can control which sign of r we find via modular sqrt
'''

'''
Updated understanding after solving the "easy" part:

The server doesn't check that p and q are distinct. If n == p**2, then the method the server uses to solve for p/q in step 4 fails, so we "win" every round.
For step 3, we need different algorithms for the composite vs. prime power case:
- In the composite case, we can solve for roots of a = sqrt(s) mod p and b = sqrt(s) mod q seperately via tonelli-shanks, then combine into a root mod pq via CRT of (x = a mod p, x = b mod q)
- In the prime power case, we use hensel's lemma on the polynomial (x**2 - s) to turn the tonelli-shanks root a = sqrt(s) mod p into a root mod p**2

In order to solve the "hard" part, the possible approaches seem to be
a) seeing if their primality test can be confused into accepting composites, which might make it easier to "lose" the rounds
b) still giving n = p**2, but somehow giving a root of s that allows the server to solve for p
c) figuring out a way to give n=p*q, with distinct primes p & q, and give a root that gives more information about n/helps the server solve for p
'''

def gen_prime(bits):
    a = int(os.urandom(bits/8).encode('hex'), 16) | 1
    while not gmpy.is_prime(a):
        a += 2
    return a

def atkins(end):
    n = (end-begin)/2
    array = [1]*n
    for i in range(gmpy.sqrt(n)):
        pass

def extended_euclidean(a, b):
    if b > a:
        a, b = b, a
    rst = [(a, 1, 0), (b, 0, 1)]
    while rst[-1][0] != 0:
        ra, sa, ta = rst[-2]
        rb, sb, tb = rst[-1]
        q = ra/rb
        rst.append((ra-q*rb, sa-q*sb, ta-q*tb))
    r, s, t = rst[-2]
    assert a*s + b*t == gmpy.gcd(a,b)
    return (s, t)

def crt(va, vn):
    'solve for x s.t. forall i, x = va[i] mod vn[i]'
    assert len(va) == len(vn)
    assert len(va) == 2 # TODO: generalize
    a0, a1 = va
    vn = sorted(vn)[::-1]
    n0, n1 = vn
    m0, m1 = extended_euclidean(n0, n1)
    #print(m0*n0 + m1*n1)
    assert m0*n0 + m1*n1 == 1
    x = a0*m1*n1 + a1*m0*n0
    #print x
    for i in range(len(va)):
        assert x % vn[i] == va[i] % vn[i]
    return x

def evalpoly(f, x):
    'evalpoly([a, b, c], x) == ax^2 + bx + c'
    return sum(f[i]*x**(len(f) - i - 1) for i in range(len(f)))

assert evalpoly([0xa, 0xb, 0xc, 0xd], 16) == 0xabcd

def deriv(f):
    'd/dx(ax^3 + bx^2 + cx + d) = 3ax^2 + 2bx + c'
    return [(len(f) - i - 1)*f[i] for i in range(len(f)-1)]

assert deriv([1, 1, 1, 1]) == [3, 2, 1]

def hensel(f, p, k, m, r):
    'https://en.wikipedia.org/wiki/Hensel%27s_lemma#Alternative_statement'
    assert evalpoly(f, r) % (p**k) == 0
    assert evalpoly(deriv(f), r) % p != 0
    a = gmpy.invert(evalpoly(deriv(f), r), p**m)
    s = r - evalpoly(f, r)*a
    assert evalpoly(f, s) % (p**(k+m)) == 0
    assert r % p**k == s % p**k
    return s

def easymode_generator():
    n = 0
    while n % 8 != 1:
        p, q = [gen_prime(512+8) for _ in (0, 0)]
        q = p
        n = p*q
    print('n mod 8: %r' % (n % 8,))
    #print('L(n, 8): %r' % (legendre_symbol(n, 8),))
    return ((p, q), n)

GCD_THRESH = 2

def hardmode_generator():
    n = 0
    gcdphi = 1
    while (n % 4 != 3) or (gcdphi < GCD_THRESH):
        p, q = [gen_prime(512+8) for _ in (0, 0)]
        gcdphi = gmpy.gcd(p-1, q-1)
        n = p*q
    print('n mod 8: %r' % (n % 8,))
    print('gcd(phi(p), phi(q)): %r' % (gcdphi,))
    assert not (gcdphi < GCD_THRESH)
    #print('L(n, 8): %r' % (legendre_symbol(n, 8),))
    return ((p, q), n)

def hardmode_generator2():
    n = 0
    gcdphi = 1
    while True:
        p = gen_prime(512+8)
        for _ in range(1024):
            q = gen_prime(512+8)
            gcdphi = gmpy.gcd(p-1, q-1)
            n = p * q
            if (n % 4 == 1) and (gcdphi >= GCD_THRESH):
                print('n mod 8: %r' % (n % 8,))
                print('gcd(phi(p), phi(q)): %r' % (gcdphi,))
                return ((p, q), n)

def hardmode_generator3():
    n = 0
    while n % 8 != 1:
        p, q = [gen_prime(512+8) for _ in (0, 0)]
        q = p
        n = p*q
    print('n mod 8: %r' % (n % 8,))
    #print('L(n, 8): %r' % (legendre_symbol(n, 8),))
    return ((p, q), n)

def hardmode_generator4():
    n = 0
    p = gen_prime(512+8)
    q = gen_prime(512+8)
    while True:
        n = p * q
        if prejudiced_functions.is_prime(q, 20) and not gmpy.is_prime(q):
            print('p: %d\nq: %d' % (p, q))
            print('n mod 8: %r' % (n % 8,))
            return ((p, q), n)
        q += 314
        

def play_round(proc, hardmode):
    ((p, q), n) = easymode_generator() if not hardmode else hardmode_generator()

    print proc.recvuntil('Give me a fresh composite n=p*q')
    proc.sendline('%d' % (n,))

    reg = 'Alrighty, now please give me the root of\n([0-9]+)\n'
    tmp = proc.recvregex(reg)
    s = int(re.findall(reg, tmp)[0], 10)
    print('r^2 mod n: %r' % (s,))
    a = modular_sqrt(s, p)
    b = modular_sqrt(s, q)
    assert a**2 % p == s % p
    assert b**2 % q == s % q
    #print('a: %d\nb: %d' % (a, b))
    print('L(s, p) = %d; L(s, q) = %d; J(s, n) = %d; gcd(s, n) = %d' % (gmpy.legendre(s, p), gmpy.legendre(s, q), gmpy.jacobi(s, n), gmpy.gcd(s, n)))
    if p == q:
        c = pow(a, (n+1)/4, p)
        e = pow(a, (n+3)/8, p)
        print('%d' % (a**2 % p == s % p))
        f = [1, 0, -s]
        assert evalpoly(f, a) == a**2 - s
        d = hensel(f, p, 1, 1, a)
        d2 = p**2 - d
        candidates = [a, b, c, d, d2, e]
        print('tests %d %d %d %d %d' % (gmpy.gcd(d, p**2) == 1, gmpy.gcd(d2, p**2) == 1, (d**2 - d2**2)%(p**2), gmpy.gcd(p**2, d2 - d), gmpy.gcd((d + d2)*(d - d2) % p**2, p**2)))
        print('tests2 %d' % (gmpy.gcd((d + d2)*(d - d2) / p**2, p),))
        assert d != p**2 - d
    else:
        #ans = crt([a, b], [p, q]) % n
        #candidates = [crt([x, y], [p, q]) % n for (x, y) in itertools.product([a, pow(a, p-1, p)], [b, pow(b, q-1, q)])]
        candidates = [crt([x, y], [p, q]) % n for (x, y) in itertools.product([a, p - a, b, q-b], [a, p-a, b,q - b])]
        #candidates = [crt([x, y], [p, q]) % n for (x, y) in itertools.product([a, b], [a, b])]
    print([(x*x)%p == s % p for x in candidates])
    print([(x*x)%q == s % q for x in candidates])
    print([(x*x)%n == s % n for x in candidates])
    print([gmpy.gcd(x, p**2) == 1 for x in candidates])
    candidates = list(filter(lambda c: (c*c)%n == s%n, candidates))
    candidates = sorted(candidates, key=lambda c: gmpy.legendre(c, p)+gmpy.legendre(c,q))
    #candidates = sorted(candidates)
    print(len(candidates))
    ans = None
    for (i, c) in enumerate(candidates):
        lp, lq, jn = gmpy.legendre(c, p), gmpy.legendre(c, q), gmpy.jacobi(c, n)
        print('L(c[%d], p) = %d; L(c[%d], q) = %d; J(c[%d], n) = %d' % (i, lp, i, lq, i, jn))
        if jn < 0:
            ans = c
        #print('c[%d]: %d' % (i, c))
        '''
        if lp + lq >= 1:
            ans = c
        '''
    if not hardmode:
        ans = candidates[0]
    stats = dict()
    if p != q:
        assert len(candidates) == 4
        for i in range(4):
            stats[i] = []
            for j in range(4):
                if i == j:
                    #continue
                    pass
                tmp = (candidates[i] - candidates[j]) % n
                p_hat = gmpy.gcd(n, tmp)
                q_hat = n / p_hat
                bools = p_hat == p and q_hat == q, p_hat == q and q_hat == p
                print('%d %d: %d %r %r' % (i, j, tmp, bools[0], bools[1]))
                if bools[0] or bools[1]:
                    stats[i].append(j)
    print('stats: %r' % (stats,))
    #ans = candidates[0]
    #print('ans: %d\nans^-1: %d' % (ans, gmpy.invert(ans, (p-1)*(q-1))))
    assert (ans * ans) % p == s % p
    assert (ans * ans) % q == s % q
    print('r: %r' % (ans,))
    proc.sendline('%d' % (ans,))
    print proc.recvuntil('Prove that you are not cheating!')
    #print proc.recvuntil('p:')
    proc.sendline('%d' % (p,))
    #print proc.recvuntil('q:')
    proc.sendline('%d' % (q,))

def main(hardmode):
    proc = process(['python', './prejudiced-2d332bfde033d72af2c04293710c90de7da93c1240b9e821810747dc9c195667.py']) if '--live' not in sys.argv else remote('hax.allesctf.net', 7331)

    for i in range(42):
        print('##### Round %d #####' % (i,))
        play_round(proc, hardmode)

    proc.interactive()

main('--hard' in sys.argv)
