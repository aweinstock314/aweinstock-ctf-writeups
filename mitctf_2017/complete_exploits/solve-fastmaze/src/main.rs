mod a_star;
mod maze;

use a_star::*;
use maze::*;
use std::cmp::{max, min};
use std::io::{BufRead, BufReader, Write};
use std::net::TcpStream;
use std::error::Error;

fn main() {
    if let Err(e) = solve_remote_maze(3301, 4) { println!("{:?}", e); }
    if let Err(e) = solve_remote_maze(4373, 7) { println!("{:?}", e); }
    if let Err(e) = solve_remote_maze(3221, 6) { println!("{:?}", e); }
}

fn solve_remote_maze(port: u16, headersize: usize) -> Result<(), Box<Error>> {
    let sock = TcpStream::connect(("18.181.0.70", port))?;
    let mut r = BufReader::new(sock);
    let mut tmp = String::new();
    for _ in 0..headersize {
        r.read_line(&mut tmp)?;
    }
    println!("{}", tmp);
    for _ in 0..10 {
        let mut maze1 = String::new();
        for _ in 0..20 {
            r.read_line(&mut maze1)?;
        }
        println!("{}", maze1);
        let maze1 = parse_maze(&maze1)?;
        let directions1 = solve_maze(maze1).ok_or("solve_maze failed")?;
        let mut directions1_ser = serialize_directions(directions1.iter().cloned());
        //println!("{}", directions1_ser);
        directions1_ser.push('\n');
        r.get_mut().write(directions1_ser.as_bytes())?;
        tmp.clear();
        for _ in 0..2 {
            r.read_line(&mut tmp)?;
        }
        println!("{}", tmp);
    }
    println!("{:?}", r.lines().filter_map(|x| x.ok()).collect::<Vec<String>>().join("\n"));
    Ok(())
}

fn solve_maze(m: Maze) -> Option<Vec<Direction>> {
    use Direction::*;
    let neighbors = |Coord(x, y)| {
        [(Up, Coord(x, y.wrapping_sub(1))), (Down, Coord(x, y+1)), (Left, Coord(x.wrapping_sub(1), y)), (Right, Coord(x+1, y))]
        .iter().cloned()
        .filter(|&(_, Coord(x,y))| { x < m.width && y < m.height && m[Coord(x,y)] == Tile::Empty })
        .collect()
    };
    let absdiff = |a, b| { max(a, b) - min(a, b) };
    let distance = |Coord(x1, y1), Coord(x2, y2)| {
        (absdiff(y1, y2) + absdiff(x1, x2)) as u64
    };
    shortest_path(m.start, neighbors, m.goal, distance)
}

#[test]
fn sample_maze() {
    // $ nc fastmaze.mitctf.com 3301
    let maze_str = "\
X X   X      X X    X         XX  X X XX XX  XXXX       X  X        X           
 XX    X   XXX  XX  X   X        X      X   XX                      XX          
XXX  X XX      X X X   XX          X X                                          
       XX       XX   X     X  X         X             XX           XXX   X      
   X  X  X  X   X          XX X XXX     X  X  X         X X X       X           
X   X                XX  X          X XX     X XXX XX      X X XX   X     X     
     X X          XX    X XX        XX  X   X X X  XXXX      X   X   X    XX    
 X XX     X     XXX       X   X X       X    X   X X        XX    XX X     X    
X  X    X X X            XX         X     X XX X X         X         XXX        
         X    X    X        XXX X X XX    XX   X  X XX  XX XX      XX  X        
S  X    X   X  X  X  XXXX    X X     XXX         X     X X X  X X X  X  X       
X      XXX X        XX   X     XXX X                 X    X   X  XXXXX          
      X X       X X XXX       X     XX             XXXX                         
  XXX X XX     XX   X             XX XX  XX     XX   XX X XX    X X   X         
X XX X       XX  XX    X X X  X  X   X  X X  XX  X XX     XXX        X  X   XX  
 X   X   X     X     X      X             X X  X  X   XXX   X XXX XX  XXXX  X   
X  X  X    X  XX X  X   X X XX       X XX    X    X     XX X XXX     X X   XX   
   XX     X  X    X X     X X     XXX    X      XXXX      XX  XXXX          X X 
    X  X    X  XX XX  X X  X X   X   X XXXX  X   X         X  X      X    X XX  
X     X   X X   X   XXX  X   X     X  X  X X X  X X    X X  X X  X  X    X X  X*
";
    println!("{}", maze_str);
    let maze = parse_maze(maze_str).unwrap();
    println!("{:?}", maze);
    let directions = solve_maze(maze);
    println!("{:?}", directions);
}

