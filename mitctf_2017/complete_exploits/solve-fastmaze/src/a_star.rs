use std::cmp::Ordering;
use std::collections::{BinaryHeap, HashMap, HashSet};
use std::collections::hash_map::Entry;
use std::hash::Hash;

fn invert_ord(o: Ordering) -> Ordering {
    use self::Ordering::*;
    match o {
        Less => Greater,
        Equal => Equal,
        Greater => Less,
    }
}

// BinaryHeap is a max-heap, we want a min-heap for distances in A*
#[derive(Debug, Eq, PartialEq)]
struct InvertOrd<T>(T);
impl<T: PartialOrd> PartialOrd for InvertOrd<T> {
    fn partial_cmp(&self, other: &InvertOrd<T>) -> Option<Ordering> {
        self.0.partial_cmp(&other.0).map(invert_ord)
    }
}
impl<T: Ord> Ord for InvertOrd<T> {
    fn cmp(&self, other: &InvertOrd<T>) -> Ordering {
        invert_ord(self.0.cmp(&other.0))
    }
}

// Wrapper to put items in a BinaryHeap tagged by their distance
#[derive(Debug, Eq, PartialEq)]
struct Weighted<T, D>(T, D);
impl<T: PartialEq, D: PartialOrd> PartialOrd for Weighted<T, D> {
    fn partial_cmp(&self, other: &Weighted<T, D>) -> Option<Ordering> {
        self.1.partial_cmp(&other.1)
    }
}
impl<T: Eq, D: Ord> Ord for Weighted<T, D> {
    fn cmp(&self, other: &Weighted<T, D>) -> Ordering {
        self.1.cmp(&other.1)
    }
}

pub fn shortest_path<T, D, F, G>(start: T, neighbors: F, goal: T, distance: G) -> Option<Vec<D>> where
    T: Copy+Eq+Hash,
    D: Copy+Eq+Hash,
    F: Fn(T) -> HashMap<D, T>,
    G: Fn(T, T) -> u64 {
    let mut pq = BinaryHeap::new();
    let mut backpointers = HashMap::new();
    let mut visited = HashSet::new();
    pq.push(Weighted(start, InvertOrd(distance(start, goal))));
    visited.insert(start);
    backpointers.insert(start, vec![]);
    while let Some(Weighted(x, InvertOrd(dist1))) = pq.pop() {
        if x == goal {
            return backpointers.get(&x).cloned();
        }
        let tmp = neighbors(x);
        for (dir, y) in tmp.into_iter() {
            if !visited.contains(&y) {
                visited.insert(y);
                let dist2 = distance(x, y);
                pq.push(Weighted(y, InvertOrd(dist1 + dist2)));
                let mut newpath = backpointers.get(&x).unwrap().clone();
                newpath.push(dir);
                match backpointers.entry(y) {
                    Entry::Occupied(mut e) => if e.get().len() > newpath.len() {
                        e.insert(newpath);
                    },
                    Entry::Vacant(e) => {
                        e.insert(newpath);
                    },
                }
            }
        }
    }
    None
}
