use std::error::Error;
use std::fmt::{self, Display, Formatter};
use std::ops::Index;

#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
pub struct Coord(pub usize, pub usize);

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum Tile {
    Empty,
    Blocked
}

#[derive(Clone, Debug)]
pub struct Maze {
    pub width: usize,
    pub height: usize,
    pub tiles: Vec<Tile>,
    pub start: Coord,
    pub goal: Coord,
}

impl Index<Coord> for Maze {
    type Output = Tile;
    fn index(&self, Coord(x, y): Coord) -> &Tile {
        &self.tiles[y * self.width + x]
    }
}

#[derive(Copy, Clone, Debug)]
pub enum MazeParseError {
    InconsistentLineWidth,
    UnexpectedCharType(char, Coord),
    NonUniqueStartOrGoal,
    MissingStartOrGoal,
}

impl Display for MazeParseError {
    fn fmt(&self, fmt: &mut Formatter) -> Result<(), fmt::Error> {
        fmt::Debug::fmt(self, fmt)
    }
}
impl Error for MazeParseError {
    fn description(&self) -> &str {
        use self::MazeParseError::*;
        match *self {
            InconsistentLineWidth => "InconsistentLineWidth",
            UnexpectedCharType(_, _) => "UnexpectedCharType",
            NonUniqueStartOrGoal => "NonUniqueStartOrGoal",
            MissingStartOrGoal => "MissingStartOrGoal",
        }
    }
}

pub fn parse_maze(s: &str) -> Result<Maze, MazeParseError> {
    use self::MazeParseError::*;
    let mut width = 0;
    let mut height = 0;
    let mut tiles = vec![];
    let mut start = None;
    let mut goal = None;
    for (y, line) in s.lines().enumerate() {
        if y == 0 {
            width = line.len();
        }
        let mut tmpwidth = 0;
        for (x, c) in line.chars().enumerate() {
            tmpwidth += 1;
            let coord = Coord(x, y);
            let tile = match c {
                'X' => Tile::Blocked,
                ' ' => Tile::Empty,
                'S' => {
                    if let Some(_) = start {
                        return Err(NonUniqueStartOrGoal);
                    }
                    start = Some(coord);
                    Tile::Empty
                },
                '*' => {
                    if let Some(_) = goal {
                        return Err(NonUniqueStartOrGoal);
                    }
                    goal = Some(coord);
                    Tile::Empty
                },
                _ => return Err(UnexpectedCharType(c, coord)),
            };
            tiles.push(tile);
        }
        if tmpwidth != width {
            return Err(InconsistentLineWidth);
        }
        height += 1;
    }
    if let (Some(start), Some(goal)) = (start, goal) {
        Ok(Maze {
            width: width,
            height: height,
            tiles: tiles,
            start: start,
            goal: goal,
        })
    } else {
        Err(MissingStartOrGoal)
    }
}

#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
pub enum Direction { Up, Down, Left, Right }

pub fn serialize_directions<I: Iterator<Item=Direction>>(i: I) -> String {
    use Direction::*;
    let mut s = String::new();
    for d in i {
        s.push(match d { Up => 'u', Down => 'd', Left => 'l', Right => 'r' })
    }
    s
}
