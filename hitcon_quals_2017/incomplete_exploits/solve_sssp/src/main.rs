#![feature(i128_type)]
#![feature(global_allocator, allocator_api)]
//extern crate permutohedron;
extern crate fnv;
//extern crate mersenne_twister;
extern crate rand;
extern crate rayon;

use std::error::Error;
use std::io::BufReader;
use std::io::prelude::*;
use std::net::TcpStream;
use std::process::Command;
use std::thread::sleep;
use std::time::{Duration, Instant};
//use std::collections::{HashMap, HashSet};
use fnv::{FnvHashMap, FnvHashSet};
use rand::{Rng, SeedableRng};
//use permutohedron::LexicalPermutation;

mod mt19937;
use mt19937::*;

#[global_allocator] static ALLOCATOR: std::heap::System = std::heap::System; // this is to reduce binary size

fn floating_seconds(d: Duration) -> f64 {
    d.as_secs() as f64 + (d.subsec_nanos() as f64 / 1_000_000_000.0)
}

fn calc_nm(i: usize) -> (usize, usize) {
    let n = 4 * i + 7;
    let m = (4 * i + 20).min(120);
    (n, m)
}
    
fn infer_samples(p: &Prob, i: usize) -> Vec<Option<u32>> {
    println!("Problem {}: {:?}", i, p);
    let (n, m) = calc_nm(i);
    let mut mtrands = vec![];

    let mut lens = vec![32; m/32];
    if m % 32 != 0 {
        lens.push(m % 32);
    }
    lens.reverse();
    
    for val in p.vals.iter() {
        /*let mut val = val.abs();
        let mut k = m;
        //println!("trying {} {}", val, k);
        let mut x = vec![];
        let mut j1 = 0;
        let mut j2 = 0;
        let mut should_push = true;
        if val == val >> (k % 32) {
            should_push = false;
        }
        val >>= k % 32;
        k -= k % 32;
        
        while k > 0 {
            x.push((val & 0xffffffff) as u32);
            k -= 32;
            val >>= 32;
            if k >= 32 {
                j1 += 1;
            }
            j2 += 1;
            should_push = false;
        }
        x.reverse();
        println!("got {:?}, {} {}; {} {} {}", x, j1, j2, i, n, m); 
        for l in 0..j2 {
            mtrands.push(if l <= j1 { Some(x[l]) } else { None });
        }
        if should_push {mtrands.push(None);}
        mtrands.push(None); // sign only known as bit, not full 32-bit val*/
        let mut val = val.abs();
        let mut splitvals = vec![];
        for blen in lens.iter() {
            let mask = ((1 << 32)-1) >> (32 - blen);
            splitvals.push(((val&mask) as u32,mask));
            val >>= blen;
        }
        splitvals.reverse();
        for &(val, mask) in splitvals.iter() {
            if mask == ((1 << 32)-1) {
                mtrands.push(Some(val));
            } else {
                mtrands.push(None);
            }
        }
        mtrands.push(None); // sign bit
    }
    for _ in 0..n {
        mtrands.push(None); // goal only known as bit, not full 32-bit val
    }
    mtrands
}

#[test]
fn test_infer_samples() {
    let mut mtr = mtrand_from_sseq(&[0u32; 624][..]);
    let mut mtrands = vec![];
    for i in 1..30 {
        let (n, m) = calc_nm(i);
        let prob = Prob::gen_instance(&mut mtr, n, m).0;
        mtrands.extend_from_slice(&infer_samples(&prob, i));
    }
    let expected = {
        let mut mtr = mtrand_from_sseq(&[0u32; 624][..]);
        mtrands.iter().map(|_| mtr.next_u32()).collect::<Vec<_>>()
        };
    
    for (i, (x,y)) in mtrands.iter().zip(expected).enumerate() {
        println!("{}: {:?}, {}", i, x, y);
        if let &Some(x) = x {
            assert_eq!(x, y);
        }
    }
}

fn main2() -> Result<(), Box<Error>> {
    //let mut sock = BufReader::new(TcpStream::connect(("0.0.0.0", 50216))?);
    let mut sock = BufReader::new(TcpStream::connect(("54.92.67.18", 50216))?);
    let mut times = vec![];

    let mut i = 0;
    let mut mtrands = vec![];
    let mut predicted_mtrand = None;

    let format_sol = |sol: Vec<i128>| {
        let mut buf = format!("{}\n", sol.len());
        for x in sol {
            buf += &format!(" {}", x);
        }
        println!("sending {:?}", buf);
        buf
    };
    loop {
        i += 1;
        let (n, m) = calc_nm(i);
        println!("i: {}, n: {}, m: {}", i, n, m);

        let mut tmp = String::new();
        sock.read_line(&mut tmp).unwrap();
        if !tmp.starts_with("Prob")  {
            println!("output {:?}", tmp);
            break Ok(());
        }
        let prob = parse_prob(tmp)?;
        println!("{:?}", prob);

        let prevcount = mtrands.len();

        mtrands.extend_from_slice(&infer_samples(&prob, i)[..]);
        println!("amount of Some mtrands {}", mtrands.iter().filter_map(|&x| x).count());
        println!("known indices {:?}", mtrands.iter().enumerate().filter_map(|(i, &x)| x.map(|_| i)).collect::<Vec<_>>());

        if let None = predicted_mtrand {
            predicted_mtrand = check_mtrands(&mtrands, prevcount);
            println!("predicted: {:?}", predicted_mtrand.is_some());
        }

        if let Some(mut mtr) = predicted_mtrand.take() {
            let prob2 = Prob::gen_instance(&mut mtr, n, m);
            println!("prob2: {:?}", prob2);
            if prob2.0.goal == prob.goal {
                println!("SUCESSFULLY PREDICTED {}", i);
                let sol = prob2.1.iter().map(|&i| prob2.0.vals[i]).collect::<Vec<_>>();
                writeln!(sock.get_ref(), "{}", format_sol(sol))?;
                predicted_mtrand = Some(mtr);
                continue;
            } else {
                println!("DESYNCED");
                predicted_mtrand = None;
            }
        }

        let starttime = Instant::now();
        if let Some(sol) = halfexptime_solve(&prob) {
            let delta = Instant::now()-starttime;
            times.push(floating_seconds(delta));
            println!("Time graph: {:?}", times);
            //println!("{:?}", sol);
            writeln!(sock.get_ref(), "{}", format_sol(sol))?;
        } else {
            println!("Error solving instance");
            return Ok(());
        }
    }
}

fn check_mtrands(mtrands: &[Option<u32>], prevcount: usize) -> Option<MT19937> {
    println!("mtrands: {}: {:?}", mtrands.len(), mtrands);
    //let mut mtr = MT19937::from_seed(0u32);
    //let mut mtr = MT19937::from_seed(0u64);
    //let mut mtr = MT19937::from_seed(&[0u32; 2*624][..]);
    let seed = &[0u32; 624][..];
    let mut mtr = mtrand_from_sseq(seed); // TODO more general seed recovery
    let mut num_samples = 0;
    let mut num_agreements = 0;
    {
        let mut f = || { num_samples += 1; (mtr.next_u32(), num_samples) };
        let tmp = mtrands.iter().filter_map(|&x| x).collect::<FnvHashSet<_>>();
        println!("{:?}", tmp);
        /*for _ in 0..(2usize.pow(10)) {
            let y = mtr.next_u32();
            if tmp.contains(&y) {
                println!("found agreement {}", y);
            }
        }*/
        /*for _ in 0..(78-52) {
            println!("skipping {}", f().0);
        }*/
        for (i, x) in mtrands.iter().enumerate().take(prevcount) {
            let (y, samp) = f();
            if let &Some(x) = x {
                println!("i: {}, agreement: {}, x: {}, y: {}, num_samples: {}", i, x==y, x, y, samp);
                if x == y {
                    num_agreements += 1;
                }
            } else {
                //println!("i: {}, y: {}", i, y);
            }
        }
    }
    if num_agreements >= 5 {
        Some(mtr)
    } else {
        None
    }
}

#[test]
fn test_mtrand_cpp() {
    /*
    :!cat test.cpp
    #include <random>

    int main() {
        std::mt19937 m;
        for(int i=0; i<10; i++) {
            printf("%d, ", m());
        }
        printf("\n");
    }
    :!g++ test.cpp -std=c++11 && ./a.out
    -795755684, 581869302, -404620562, -708632711, 545404204, -133711905, -372047867, 949333985, -1579004998, 1323567403,
    */
    let mut mtr = MT19937::new_unseeded();
    assert_eq!(
        (0..10).map(|_| mtr.next_u32() as i32).collect::<Vec<_>>(),
        [-795755684, 581869302, -404620562, -708632711, 545404204, -133711905, -372047867, 949333985, -1579004998, 1323567403]
        );
}

fn seedseq_generate(init: &[u32], n: usize) -> Vec<u32> {
    // /usr/include/c++/4.8/bits/random.tcc
    let mut result = vec![0x8b8b8b8b; n];
    let s = init.len();
    let t = if n >= 623 { 11 }
        else if n >= 68 { 7 }
        else if n >= 39 { 5 }
        else if n >= 7 { 3 } 
        else { (n-1)/2 };
    let p = (n - t) / 2;
    let q = p + t;
    let m = (s+1).max(n);

    for k in 0..m {
        let arg = result[k % n]
            ^ result[(k + p) % n] 
            ^ result[(k - 1) % n];
        let mut r1 = arg ^ (arg >> 27);
        r1 = 1664525u32.wrapping_mul(r1);
        let r2 = if k == 0 { r1.wrapping_add(s as u32) }
            else if k <= s { r1.wrapping_add((k % n) as u32).wrapping_add(init[k-1]) }
            else { r1.wrapping_add((k % n) as u32) };
        result[(k+p)%n] = result[(k+p)%n].wrapping_add(r1);
        result[(k+q)%n] = result[(k+q)%n].wrapping_add(r2);
        result[k%n] = r2;
    }

    for k in m..(m+n) {
        let arg = result[k % n]
            .wrapping_add(result[(k + p) % n])
            .wrapping_add(result[(k - 1) % n]);
        let mut r3 = arg ^ (arg >> 27);
        r3 = 1566083941u32.wrapping_mul(r3);
        let r4 = r3.wrapping_sub((k % n) as u32);
        result[(k+p)%n] ^= r3;
        result[(k+q)%n] ^= r4;
        result[k%n] = r4;
    }
    result
}
#[test]
fn test_seedseq_generate() {
    // vectors from http://en.cppreference.com/w/cpp/numeric/random/seed_seq/generate
    assert_eq!(seedseq_generate(&[1,2,3,4,5][..], 10),
        [4204997637, 4246533866, 1856049002, 1129615051, 690460811, 1075771511, 46783058, 3904109078, 1534123438, 1495905678]);
}
fn invert_seedseq(mut result: Vec<u32>) -> Vec<u32> {
    let (s,n) = (624, 624);
    let t = 11;
    let p = (n-t)/2;
    let q = p+t;
    let m = (s+1).max(n);

    let mut init = [0; 624];

    let reversed = |range: std::ops::Range<usize>| { let mut x = range.collect::<Vec<_>>(); x.reverse(); x};

    for k in reversed(m..(m+n)) {
        let r4 = result[k%n];
        result[(k+q)%n] ^= r4;
        let r3 = r4.wrapping_add((k % n) as u32);
        result[(k+p)%n] ^= r3;
    }
    for k in reversed(0..m) {
        let r2 = result[k%n];
        result[(k+q)%n] = result[(k+q)%n].wrapping_sub(r2);
        // could we guess at arg's parts/init here?
        let r1 = if k == 0 { r2.wrapping_sub(s as u32) }
            else if k <= s { r2.wrapping_sub((k%n) as u32).wrapping_sub(0x8b8b8b8b) /* this is where the guesswork starts */ }
            else { r2.wrapping_sub((k%n) as u32) };
        if k > 0 {
            init[k-1] = r1;
        }
        result[(k+p)%n] = result[(k+p)%n].wrapping_sub(r1);
    }
    result
}
#[test]
fn test_invert_seedseq() {
    let test = [0u32; 624];
    let seed = seedseq_generate(&test[..], 624);
    println!("{:?}", seed);
    let inv = invert_seedseq(seed);
    println!("{:?}", &inv[..]);
    assert!(false);
    
}

fn mtrand_from_sseq(init: &[u32]) -> MT19937 {
  /*void seed(_Sseq& __q)
  {
const unsigned long __upper_mask = (~unsigned long()) << 31;
const size_t __k = (32 + 31) / 32;
uint_least32_t __arr[624 * __k];
__q.generate(__arr + 0, __arr + 624 * __k);

bool __zero = true;
for (size_t __i = 0; __i < state_size; ++__i)
  {
    unsigned long __factor = 1u;
    unsigned long __sum = 0u;
    for (size_t __j = 0; __j < __k; ++__j)
      {
    __sum += __arr[__k * __i + __j] * __factor;
    __factor *= __detail::_Shift<unsigned long, 32>::__value;
      }
    _M_x[__i] = __detail::__mod<unsigned long,
      __detail::_Shift<unsigned long, 32>::__value>(__sum);

    if (__zero)
      {
    if (__i == 0)
      {
        if ((_M_x[0] & __upper_mask) != 0u)
          __zero = false;
      }
    else if (_M_x[__i] != 0u)
      __zero = false;
      }
  }
    if (__zero)
      _M_x[0] = __detail::_Shift<unsigned long, 32 - 1>::__value;
_M_p = state_size;
*/
    let upper_mask = std::num::Wrapping((!0u32) << 31);
    let arr = seedseq_generate(init, 624);
    let mut result = MT19937 {
        idx: 624,
        state: [std::num::Wrapping(0); 624],
    };
    let mut zero = true;
    for i in 0..624 {
        let mut factor = 1u32;
        let mut sum = 0u32;

        sum += arr[i] * factor;
        factor = 32u32.wrapping_mul(factor);

        result.state[i] = std::num::Wrapping(sum);
        if zero {
            if i == 0 {
                if (result.state[0] & upper_mask).0 != 0 {
                    zero = false
                }
            } else if result.state[i].0 != 0 {
                zero = false
            }
        }
        if zero {
            result.state[0] = std::num::Wrapping(31);
        }
    }

    result
}

#[test]
fn test_seed_seq() {
    /*
    :!cat test2.cpp
    #include <array>
    #include <cstring>
    #include <random>

    using namespace std;
    typedef mt19937 T;

    int main() {
        array<typename T::result_type, T::state_size> data;
        printf("state size %d\n", T::state_size);
        printf("result_type size %d\n", sizeof(typename T::result_type));
        //random_device rd;
        //generate(begin(data), end(data), ref(rd));
        memset(&data, 0, sizeof data);
        auto seq = seed_seq(begin(data), end(data));
        auto r = T{seq};
        for(int i=0; i<10; i++) {
            printf("%d, ", r());
        }
        printf("\n");
    }
    :!g++ test2.cpp -std=c++14 && ./a.out
    state size 624
    result_type size 8
    -412023808, -496825549, -369264223, -552272902, 1480766257, -2140279596, 842911426, 1229763740, 542415433, 1566094725,
    */
    //let mut mtr = MT19937::from_seed(&[0u32; 2*624][..]);
    let mut mtr = mtrand_from_sseq(&[0u32; 624][..]);
    assert_eq!(
        (0..10).map(|_| mtr.next_u32() as i32).collect::<Vec<_>>(),
        [-412023808, -496825549, -369264223, -552272902, 1480766257, -2140279596, 842911426, 1229763740, 542415433, 1566094725]
        );
}

#[derive(Debug,Clone, Eq, PartialEq)]
struct Prob {
    goal: i128,
    vals: Vec<i128>,
}

impl Prob {
    fn gen_instance(mtr: &mut MT19937, n: usize, m: usize) -> (Prob, Vec<usize>) {
        fn sample(mtr: &mut MT19937, mut n: usize, sign: bool) -> i128 {
            let mut r = || {let x = mtr.next_u32(); /*println!("next: {}", x);*/ x} ;
            let mut val = 0i128;
            while n > 0 {
                let w = n.min(32);
                let mask = (!0) >> (32-w);
                val = (val << w) | (r() & mask) as i128;
                n -= w;
            }
            if sign && (r() % 2 == 1) {
                val = -val;
            }
            val
        }
        let mut p = Prob { goal: 0, vals: vec![] };
        for _ in 0..n {
            p.vals.push(sample(mtr, m, true));
        }
        let mut sol = vec![];
        for i in 0..n {
            if sample(mtr, 1, false) != 0 {
                sol.push(i);
                p.goal += p.vals[i];
            }
        }
        (p, sol)
    }
}

#[test]
fn test_prob_gen() {
    //let mut mtr = MT19937::from_seed(&[0u32; 2*624][..]);
    //let mut mtr = MT19937::new_unseeded();
    //let mut mtr = MT19937::from_seed(5489u64);
    //let mut mtr = MT19937::from_seed(0u32);
    let mut mtr = mtrand_from_sseq(&[0u32; 624][..]);
    let probs = (1..9).map(|i| { let (n, m) = calc_nm(i); Prob::gen_instance(&mut mtr, n, m).0 }).collect::<Vec<_>>();
    // generated with s/generate(begin(data), end(data), ref(rd));/memset(&data, 0, sizeof data);/ in sssp.cpp
    let cpp_probs_0_memset = vec![
        Prob { goal: 3727753, vals: vec![-7406592, 16611745, 4371249, 4050626, -5544521, 6590929, -2986812, -12909849, 9993842, -8261215, 10574990] },
        Prob { goal: 35632066, vals: vec![98407325, 146066661, 152281186, -258936030, 99886606, -92524185, -208698931, -192343010, -238211193, 226300686, 85375500, 156465405, 247097736, -174702173, -36411295] },
        Prob { goal: -26266449, vals: vec![-2510088319, 1628340218, 2971021580, -702971592, 1332669318, -1114506042, -2276978336, -3445716002, -107958922, -3856001631, 2917780093, -2682343021, 3387641365, 1680507921, 3758891711, -25471463, 2887256854, 1900494792, -2084841486] },
        Prob { goal: 9619454995, vals: vec![60592930452, 36580623242, -1368807795, -3125837954, 7910210499, -32261366528, -49227725563, 25534267769, 26296961481, -26115007359, 7696044254, -12937104047, -43153965222, 45516943185, -11250556775, 7215203809, 42667840454, 13501725212, -57758832432, 47944716683, -49055980702, -22171943088, -6299657403] },
        Prob { goal: 570515132865, vals: vec![-515430180083, 887109795570, 316113514666, 989874521278, 699807745317, 898947158290, 347600057064, 741203655273, -700408583247, -341453382557, -63576096313, -1063142308932, -1082634332553, 117380936709, -385091436150, -231615116514, -739910633059, 891852151226, 496268956558, 930084338391, 1037588455206, -976898903312, 711566369130, 443555606876, 838272217714, 1031463677280, 910073288563] },
        Prob { goal: -18819090222765, vals: vec![15696096988099, -7732232474535, -1590166766369, 1359280899500, 6584823921462, 6532079769880, 3711321893643, 311428537545, -3173407270602, 8065614643212, 1265925129392, -14757724091191, 6067981249632, -16757087215185, -14229533491749, 3391772089458, 8070407015611, -16645608583128, 16843531416637, -14598620818017, 10348110800075, -7930666066884, -12820800943697, 3395754404154, -11044046189496, -891725925740, 15347584789543, 3797578975309, 14814958099253, 3027370051764, -11920111822141] },
        Prob { goal: -1278576240134063, vals: vec![-254077997227103, -122943525912871, 262944785149655, -225064843598404, -53722716524396, -212609517035418, -72244514790398, 277209332376850, 229504193634063, 247023578638860, -269397144542530, -162256125675858, -242701321560418, 198247089425436, -122036855820364, 132907550253750, 173836914643409, 166114933082544, 110993735991312, 208413621728307, 246511586671876, 2510355979883, -172746882519287, 158743119004062, -30224996756289, -158077658734844, -168223748750553, 83222322516874, 279923423192340, -170687487989475, 7634595703008, -249631544735161, -176536675986493, 181875617866351, 57225723697361] },
        Prob { goal: -9080790717989681, vals: vec![-504893854797416, 4336377081683997, 1575670135799053, 828736775922091, -980550173261370, 3007613756751539, -4291787483678058, 2822378728837741, -1642498617790993, -1001987583792065, -2821049432080365, -2681334602014474, 1398051846615014, -4198954027674419, -2152119801643903, -3506466622863524, -1419482366551152, 2928456835925828, -2392485972774657, -1970475398030625, -3560550327742519, -82181499353504, 4059168099176653, 2977383267235158, 1003877135656051, -1392705639754109, -433080564550966, -394192119765601, -3064041734801960, -3863910034152122, 1140802133182001, 3011930227814074, 2826953747336043, -2893627954653143, -2325597052987265, 1184597036726748, 1368762303211866, 123326050481622, 2723636565452212] },
        Prob { goal: 171728203128483987, vals: vec![17812021347795412, -39389738063503886, 24064312132515841, -8522466291963719, -13185231111842854, 4832167349071430, 14852358584359499, -16889573747878826, 59036943281846965, -12775886461670620, -17524473361377207, -36091428248215449, -26468979837906709, -66687612588180080, 20524214677727919, 70800449521631796, 43376730760447641, 45654067772651420, -21183628691263619, -56717985938496651, 70103893480004748, 40269106965374733, -13181149325117343, -62232986658382906, -52754046523360791, 56886917354416668, 52152773412108051, -17170463042064103, 50222932235280625, 4345736081871331, 32068353312725288, 31642002102874433, 7085137239321004, -25859422010282113, 62851867406224461, 39481564817079085, -27905837582609745, -1159539695626394, -57457128436776079, 48617449121555983, 53797614316404868, -44292044755041389, -4773076804111045] },
    ];
    // s/T{seq}/T{}
    let cpp_probs_default = vec![
        Prob { goal: -27172830, vals: vec![9550684, -14809838, -8533292, -13828101, -14830522, -16279651, 4958404, 27999, 2042599, 192345, -5854369] },
        Prob { goal: -188967363, vals: vec![214595962, -63408135, -14734509, 15731080, -205851834, -209568640, -104901708, -242062374, 101956166, 228265677, 160024814, 202240050, 209874315, -222965182, 203065689] },
        Prob { goal: 2799806504, vals: vec![147944788, -1884392678, 1638781099, -3287869586, -3415357582, -802611720, 2103522059, -1913778154, 2775893247, -3046698742, 3241354600, -1185518681, -2919300778, 2813624502, 698412071, -511091141, 2140457296, 4122068897, 1461945556] },
        Prob { goal: 294663224260, vals: vec![52345770426, 17695832141, 67930687146, -55957227258, -930401701, -24050701212, -58306262698, -42334267487, -67857708855, 57094108666, -40853973635, -63029068690, 46716860288, -51795868737, -14298328003, 5212667358, 24241648101, 53543964426, 66311984155, 39089264201, -26614771945, -23166891863, 63736822765] },
        Prob { goal: 1786306040594, vals: vec![613822989032, 907995366055, 600984217673, 85954902980, 664359542941, 1057618121352, 37732284991, -898634397875, 747139804542, -439565667080, -49543492772, 474344517809, 146230682827, 290054375259, 310802570113, -955796892424, 689816374636, 159379486448, 587065660493, -385876229084, 151734062647, -83526258836, 44498457700, -202208753922, 904463709622, -54595617627, -331862634967] },
        Prob { goal: 37905039642841, vals: vec![-11469554171602, -1051652866787, -9726389078458, -14446598336618, 7124507847568, -2972904005197, 4543989487761, -11395267476257, -6658649962061, 5212930782819, 10967594658572, 12081881265632, -6785491259813, 11005998063053, -11774188648578, 16349930913160, 5341233467469, 7667705326832, -13295996468046, -8945778929142, 15308487470262, 13982822071646, 9566727584637, 14277474479696, -16693666664535, -16519090208272, -290633194446, 10950697523437, 8385105631573, 5299581596105, 15836190299574] },
        Prob { goal: -597877337855485, vals: vec![37643445738479, -73806045515557, -224438043294912, -62416155211172, -91469103690539, 89728114397588, 220087860264996, -24070555060881, 51108250078029, -8224777789505, 68718812264122, 137531200430046, 79271049272769, 129154463420265, -170553628784046, -146686696859039, 113032322508552, -175657298631048, 84175602809911, -103424223580261, -216522705879311, -249152644418576, 5085202986188, 27785036139682, 92266868372024, -191326409453859, -238440168709533, -30050793186481, 449769975521, -219283566017768, 27781310528278, 250772390486465, 202653802365378, 55678517200528, -119339291485837] },
        Prob { goal: -11976535248442540, vals: vec![1433190151696004, -3071328395688571, 3926261361164264, -2349302017424657, -1304645099204378, -3681904788049254, -3173793484608765, -2970597987877147, -4215617237605464, -2922797832045220, -2128996287125032, -1947318230956896, -2278458489980691, -599748903289776, 3215137430601727, -3744201499464287, -1787847114426898, -1798097124222292, 4093486418845350, -2958233963209326, 2319460632328168, 1943984062377908, -3675464311478703, 752859613227441, 2219327001869984, -892245945565565, -919622284544607, -4285762584964031, 1767523632299342, 3323017465478363, 4376946699859045, 2467391177929851, -590970675611393, -4427274719583628, 1398322471056719, -3000923398855667, 1093130150939405, -3001774877923950, 1408171744005412] },
        Prob { goal: -218659021581578040, vals: vec![34443223446742578, 42008595986979057, 47177806040945100, -44466084497548626, -71803595846734503, -70808360156491815, 55693381238018778, 42086630524732746, -27008091384172444, 63385731177025488, -23543857614361077, -42827881163143897, 3529611721689976, 22533770781620324, -35177365583929065, -30472125501202468, -55949392816429249, -33933668630005948, 45720687799425452, 46010989856168150, 38112748229183194, -23029588137914350, -45476983291363576, 29372058816984539, 52202406014246719, -69798540378123552, -53942971732377438, 7611386178292976, -5681191652922730, 30512998602358952, 4891617630058961, -11072133126702898, 18882605959703412, -37984637858641799, 6805174556842594, 37329588267204681, -54495835777460053, 69009120901165123, 29958846207646183, -20829297529940169, -44224926310513223, -4899394965711414, 67389290222104553] },
        Prob { goal: 1493574546416452901, vals: vec![622868249063977264, -700272089027848731, -625877386193898137, 279986525276239524, -924369773471545424, 882561436781375813, 1020269429249374969, -105046676373394707, -1066309363212280995, 630178952942641218, 1037654844484760501, 746652285085209776, 9597230902340335, -1089711561295347122, -677776092615113793, 272355312731114983, 128065785346671978, -518973422925152079, 614771723571901965, 888078733272964936, -79250186948933138, 479798184499298126, 12904173493946737, 295656337962100246, 359976774124062717, -623430012491622012, 988130100292128491, -366714439814886587, -974052961600186894, 744270634045348643, -821102225104979645, -628014915005234622, -222814042182130628, -831310158679293243, 959309006703389963, 252116991973940508, 993782376714019343, 73315861702296738, -966447938207781153, 421757339175029714, 244631184695218492, -890032789907251974, 875657129300953958, 221393607818724701, -1131639040823427745, -108167122309989194, 423346414140302235] },
        ];
    // s/T{seq}/T{0}/
    let cpp_probs_0_scalar = vec![
        Prob { goal: -18444053, vals: vec![-8325804, 1484405, -5157699, -8222403, -7644169, 5853461, -374564, 4930630, 11704920, -2701626, -11435494] },
        Prob { goal: 489516850, vals: vec![-239408080, 84418245, -65931087, 247335360, 155082851, -218660017, -87950109, 231410835, 142303655, -83836865, -160516793, -37003808, 186434250, -155050135, -263420414] },
        Prob { goal: 10195679901, vals: vec![2928395881, -1544074682, -1877037944, -2996303169, -258666409, 2863741219, -2880367735, 903586222, 553734235, -1354754446, 1562125877, 2448976505, -1883779156, 4245033284, -438279108, 897118847, 692819075, 2805078884, 1087879144] },
        Prob { goal: 7079210100, vals: vec![42801657618, -6603831840, 60348995634, -67122511056, -31003425113, 2692964362, -67316687546, 20350599547, 47324436370, -28467935806, 14899903538, -38936555060, 34976080683, -6455542426, 5711446602, -21891891896, 57885306915, 49225630214, 18192118371, 40304861859, -11334622152, -322671080, 39143878691] },
        Prob { goal: -440157234559, vals: vec![-843351480013, 435962670411, -274653909144, -969478280558, -647024201916, -551211988597, 253473739681, -466033549540, 522122361721, -331585017119, 316649457592, 679515148073, -965868398774, -327964887974, -389278424569, 631477297014, 1065384728701, -474349585362, 155321304042, 479238546979, -286247878333, 773933684523, 109477366632, -785316612790, 924843353469, 954514698216, -558898748371] },
        Prob { goal: -15223259101103, vals: vec![-16609196628309, 3019341220642, -8612236068897, 3518376084223, 3008027952587, -3939324679038, 16609130310736, -12392189167805, -13786015405424, 10933163756891, 12298663447332, -16434866524483, 11946688498467, -10377806079005, -16967483396242, -7005579106644, -3913262573637, -16613574754860, -7953586312514, -4000720469333, 1500535488459, 7642338160273, 15498796101906, -6645480600659, 9543739414621, -1183068016841, -8419555617248, -9439601270300, 12573081410153, -3815692046294, 15945875654762] },
        Prob { goal: 50083312515925, vals: vec![247781747741142, 60041983197138, 132786263872739, 58397635609223, -205601195793037, -130484881353864, -52483322773429, 243153735293351, 189952640808218, -37173868155886, -198291876424499, -159151949435666, 57664585514547, -137375631347514, 203247637177852, -215419907605421, 26063501602118, 23481327887152, 205953483618640, 270761021165731, -80759405802602, -28230235735821, -156401356153382, 188564743191565, 277064104507088, -165059788956152, -144225938773768, -275140420459729, 170707666638297, 270657937797520, -247379839323885, 264974267581444, -136841750382897, -246090185973302, -237719713504609] },
        Prob { goal: -15239766723538368, vals: vec![3552767131256168, -3485999295968811, 1799183173619604, -1834051171569084, -4171292219192739, -240614617601298, -62818001676514, 3470387173725827, -3976047960493882, -403536187415680, 3649825652368058, 1893941364122437, -3736196349760738, -3274316276267452, 1153550130928452, -249383753509112, -2197461954866377, -2054274475078561, 1990660027875934, -1276855380728660, -3723893080582357, 3551293285911875, -2972555276085575, -3506932299532544, 3068568740136043, -1683504715941843, 43631655757797, 1670172532983467, -3509168670055784, 200915925988441, -2210450539506402, -2336625778048096, 2199603372481230, -4320903650515398, -2140513365754683, -1938360266533037, -719977317592505, -3068719063578001, -2428447191007636] },
        Prob { goal: 2064188651556953, vals: vec![-16779725842716166, -42584896910595486, -40194540175136934, -68589784479978066, -62187333387930433, 65489091207093362, -6124972578661093, -45316908445343844, 68404092406199474, 30554743869235805, 52436047243154188, 2399851255341904, -8630435210425331, 25703440261534320, 38323772451414712, -28913793946438080, -49018630737780002, 68116154143857340, -6631286248832171, 23541279869042246, -17090136685514524, 2383275317924674, -36970940453981798, -4905254154555077, 2339371136974948, -18244348062078869, -27109982270180945, 8321520297098483, -17628991907748606, -71361878419331501, -22342728418812304, -46027635210914935, -46118600750790017, 4705663981754764, 57778383812328443, 17396044803253054, -27434433376026413, 47980205738291899, 61532870154459274, -39969469132869083, 59271654704026749, 29893587944080581, -69816821622168593] },
        ];
    let allprobs = [cpp_probs_0_memset, cpp_probs_default, cpp_probs_0_scalar];
    //let allprobs = [cpp_probs_default];
    for (j, x) in probs.iter().enumerate() {
        let mut any_matched = false;
        for (i, cpp_probs) in allprobs.iter().enumerate() {
            let y = &cpp_probs[j];
            println!("Problem set {}, Problem {}: {:?} {:?}", i, j, x, y);
            any_matched |= x == y;
        }
        assert!(any_matched)
    }
}

fn parse_prob(s: String) -> Result<Prob, Box<Error>> {
    let toks = s.trim().split(' ').map(|x| x.into()).collect::<Vec<String>>();
    println!("{:?}", &toks[0..2]);
    Ok(Prob {
        goal: toks[2].parse()?,
        vals: toks[4..].iter().map(|x| x.parse()).collect::<Result<Vec<_>, _>>()?
    })
}

/*fn factorial_solve(p: &Prob) -> Option<Vec<i128>> {
    // This one gets us to round 2
    let mut tmp = (0..p.vals.len()).collect::<Vec<usize>>();
    loop {
        for i in 0..p.vals.len() {
            if tmp[0..i].iter().fold(0i128, |sum,&i| p.vals[i]+sum) == p.goal {
                tmp[0..i].sort();
                return Some(tmp[0..i].iter().map(|&i| p.vals[i]).collect())
            }
        }
        if !tmp.next_permutation() {
            break;
        }
    }
    return None
}

fn exptime_solve(p: &Prob) -> Option<Vec<i128>> {
    // This one gets us to round 5
    for i in 0..2usize.pow(p.vals.len() as u32) {
        let mut sum = 0;
        for j in 0..p.vals.len() {
            if i & (1<<j) != 0 {
                sum += p.vals[j];
            }
        }
        if sum == p.goal {
            println!("found {}", i);
            let mut tmp = vec![];
            for j in 0..p.vals.len() {
                if i & (1<<j) != 0 {
                    tmp.push(p.vals[j]);
                }
            }
            return Some(tmp);
        }
    }
    return None
}*/

fn halfexptime_solve(p: &Prob) -> Option<Vec<i128>> {
    // based on https://github.com/ymgve/ctf-writeups/blob/master/tokyowesterns2017/ppc-backpackers_problem/tcpclient-final.py
    // this one gets us to round 10
    fn gen_subsets(x: &[i128]) -> (FnvHashSet<i128>, FnvHashMap<i128, usize>) {
        let mut res = FnvHashSet::default();
        let mut bits = FnvHashMap::default();
        for i in 1..2usize.pow(x.len() as u32) {
            let mut total = 0;
            for j in 0..x.len() {
                if i & (1 << j) != 0 {
                    total += x[j];
                }
            }
            res.insert(total);
            bits.insert(total, i);
        }
        (res, bits)
    }
    let input1: Vec<i128> = p.vals[..p.vals.len()/2].iter().map(|&i| i).collect();
    let input2: Vec<i128> = p.vals[p.vals.len()/2..].iter().map(|&i| i).collect();

    // (serial)   Time graph: [0.000088346, 0.000340275, 0.000694093, 0.00364251, 0.017665702, 0.052257753, 0.197249828, 0.893641191, 4.120316192]
    // (parallel) Time graph: [0.000751227, 0.001169942, 0.001087646, 0.006823359, 0.019219382, 0.041815924, 0.195783498, 0.75461213, 3.013377922]
    /*
    let (mut set1, bits1) = gen_subsets(&input1);
    let (set2, bits2) = gen_subsets(&input2);
    */
    let ((mut set1, bits1), (set2, bits2)) = rayon::join(
        move || gen_subsets(&input1),
        move || gen_subsets(&input2)
    );

    set1.retain(|&i| set2.contains(&(p.goal-i)));
    println!("common: {:?}", set1);
    set1.iter().next().map(|x| {
        let mut answer = vec![];
        for (i, &y) in p.vals[..p.vals.len()/2].iter().enumerate() {
            if bits1[x] & (1 << i) != 0 {
                answer.push(y)
            }
        }
        for (i, &y) in p.vals[p.vals.len()/2..].iter().enumerate() {
            if bits2[&(p.goal-x)] & (1 << i) != 0 {
                answer.push(y)
            }
        }
        answer
    })
}

fn main() {
    //Command::new("sh").args(&["-c", "g++ sssp-58ab171bacc3c82fa6704228fb9f1d78.cpp -o sssp -std=c++14"]).spawn().unwrap().wait().unwrap();
    Command::new("sh").args(&["-c", "g++ sssp-patched.cpp -o sssp -std=c++14"]).spawn().unwrap().wait().unwrap();
    let mut socat = Command::new("socat").args(&["TCP-LISTEN:50216,fork,reuseaddr", "EXEC:./sssp"]).env("FLAG", "hitcon{placeholder}").spawn().unwrap();
    sleep(Duration::from_millis(100));

    if let Err(e) = main2() {
        println!("Error: {:?}", e);
    }

    socat.kill().unwrap();
}
