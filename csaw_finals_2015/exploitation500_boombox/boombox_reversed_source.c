// from documentation on GetStdHandle: https://msdn.microsoft.com/en-us/library/windows/desktop/ms683231(v=vs.85).aspx
#define STD_INPUT_HANDLE (-10)
#define STD_OUTPUT_HANDLE (-11)
#define STD_ERROR_HANDLE (-12)

// fancy_print at 0x140002b50 seems to get inlined almost everywhere, but not in a few places (e.g. end of eject_mixtape)
#define PRINT(x) { \
    printf("|"); \
    printf(" %s", x); \
    fflush(__iob_func() + 0x30); \
}

#define NEWLINE { \
    /* this might be a (unimportant) bug (use of char instead of int) */ \
    register char newline_tmp = getchar(); \
    while(newline_tmp != '\n' && newline_tmp != -1) { newline_tmp = getchar(); } \
}

// 0x140003320
// this contains a ton of printf/SetConsoleTextAttribute, and prints an ascii art boombox
void print_boombox();

// sizeof struct track_t == 0x228
struct track_t {
    char name[0x20]; // offset 0x0
    uint64_t length; // offset 0x20
    char data[0x200]; // offset 0x28
};

// sizeof struct tape_t == 0x90
struct tape_t {
    struct boombox_t* box; // offset 0x0
    char name[0x20]; // offset 0x8
    uint64_t num_tracks; // offset 0x28
    struct track_t* tracks[12]; // offset 0x30
};

// sizeof struct boombox_t == 0x60, assuming memset + explicit zeroing are both meant to target this
struct boombox_t {
    //uint32_t i; // rbp-0x59
    //char buf[0x5c]; // rbp-0x55
    uint32_t current_track; // offset 0x0
    uint32_t current_tape; // offset 0x4
    uint64_t current_position; // offset 0x8
    struct tape_t* tapes[10]; // offset 0x10
};

int main_ish(char* input) {
    // input at rbp+0x1f
    // stack cookie? at rbp+0x37
    struct boombox_t boombox; // rbp-0x59
    //*(uint32_t*)(/* rbp-0x59 */) = 0;
    //memset(/* rbp-0x55 */, 0, 0x5c);
    memset(&boombox, 0, sizeof struct boombox_t);
    //stdout and ConsoleScreenBufferInfo are rip-relative globals
    stdout = GetStdHandle(STD_OUTPUT_HANDLE); // 0x1400075e0
    GetConsoleScreenBufferInfo(stdout, &ConsoleScreenBufferInfo);
    register int show_boombox asm("bl") = 1; // stored in %bl ...?
    while(1) {
        if(show_boombox) { print_boombox(); }
        show_boombox = 1;
        // I'm going to simplify alternating printf/SetConsoleTextAttribute's to just printf's
        // this drops the colors, but makes for faster reversing
        PRINT("MENU SELECTION: ");
        fgets(input, 0x14, __iob_func());
        if(input[0] == '\r' || input[0] == '\n') { show_boombox = 0; continue; }
        // most of the following strnicmp's are unrolled
        // strnicmp seems to be Windows' version of the POSIX strncasecmp
#define TEST(x) (!strnicmp(input, x, strlen(x)))
        if(TEST("1\n")) { upload_mixtape(&boombox); goto continuish; }
        if(TEST("2\n")) { eject_mixtape(&boombox); goto continuish; }
        if(TEST("3\n")) { select_mixtape(&boombox); goto continuish; }
        if(TEST("4\n")) { play(&boombox); goto continuish; }
        if(TEST("5\n")) { fast_forward(&boombox); goto continuish; }
        if(TEST("6\n")) { rewind(&boombox); goto continuish; }
        if(TEST("7\n")) { next_track(&boombox); goto continuish; }
        if(TEST("8\n")) { previous_track(&boombox); goto continuish; }
        if(TEST("9\n")) { record(&boombox); goto continuish; }
        if(TEST("10\n")) { seek(&boombox); goto continuish; }
        if(TEST("11\n") || TEST("h\n") || TEST("help\n")) { print_menu(); goto continuish; }
        if(TEST("12\n") || TEST("q\n") || TEST("quit\n") || TEST("exit\n") ||
            TEST("windows_is_hard_and_i_am_a_big_baby\n")) { quit(); }
        // the "windows_is_hard_and_i_am_a_big_baby" case can't be triggered, since it's longer than 0x14 bytes
#undef TEST
        PRINT("UNKNOWN COMMAND! 'help' for commands \n");
        continuish:
        PRINT("PRESS ENTER TO RETURN TO MENU ");
        NEWLINE;
    }
}

void* wrapmalloc(size_t n) {
    void* ret = malloc(n);
    if(!ret) {
        PRINT("Out of memory...\n");
        exit(1);
    }
    return ret;
}

void getstring(char* buf, size_t n) {
    // buf in %rdi
    // n in %rbx
    int i; // %rax
    int j; // %rdx
    memset(buf, 0, n);
    fgets(buf, n, __iob_func());
    if(n > 0) {
        for(i=0, j=0; i<n; i++, j++) {
            if(buf[i] == '\n') {
                buf[i] = 0;
                return;
            }
        }
        NEWLINE;
    }
}

int upload_mixtape(struct boombox_t* boombox) {
    // boombox is in %r13
    tape_t** dst_tape = &boombox->tapes[0];
    int i = j = k = 0; // i == rdx, j == esi, k == edi
    uint64_t tracks; // rsp+0x58
    while(*dst_tape) {
        i++; j++; dst_tape++;
        if(i >= 10) {
            PRINT("No more open slots! Please eject a mixtape and try again...\n");
            return;
        }
    }
    tape_t* tape = malloc(sizeof struct tape_t);
    PRINT("Mixtape name: ");
    getstring(&tape->name[0], 0x20);
    PRINT("Number of tracks: ");
    scanf("%llu", &tracks);
    NEWLINE;
    tape->num_tracks = tracks;
    tape->box = boombox;
    // 1 and 12 both pass, 0 and 13 fail (verified dynamically)
    if(tracks-1 <= 11) {
        track_t** p_track = &tape->tracks[0];
        do {
            track_t *track = wrapmalloc(sizeof struct track_t);
            PRINT("Track name: ");
            getstring(track->name, 0x20);
            PRINT("Upload track data now...\n");
            getstring(track->data, 0x200);
            // strlen is inlined
            // possible memory disclosure bug (if getstring doesn't null-terminate)
            track->length = strlen(track->data);
            *p_track = track;
            p_track++;
            k++;
        } while(k < tape->num_tracks);
        boombox->tapes[j] = tape; // TODO: ask markus why dst_tape isn't used here (and j omitted)?
        PRINT("Upload complete!\n");
        return 0;
    }
    else {
        PRINT("Invalid number of tracks...\n");
        return 1;
    }
}

void show_tapes(struct boombox_t* boombox) {
    PRINT("Uploaded Mixtapes\n");
    register int i asm("ebx") = 1;
    register int j asm("rsi") = 9;
    tape_t** tape = &boombox->tapes[0];
    do {
        PRINT("");
        if(!*tape) {
            printf("  %2u. EMPTY\n", i);
        } else {
            printf("  %2u. %s\n", i, tape->name);
        }
        i++;
        tape++;
    } while(j--);
}

int eject_mixtape(struct boombox_t* boombox) {
    // boombox in %rbx
    uint64_t to_eject; // %rdx, rsp+0x48
    struct tape_t** p_tape; // %r14
    struct tape_t* tape; // %rsi
    struct track_t** p_track; // %rdi
    int zero; // %rbp
    int i; // %rbx
    show_tapes(boombox);
    PRINT("What mixtape do you want to eject? ");
    zero = 0;
    scanf("%llu", &to_eject);
    NEWLINE;
    if(to_eject-1 >= 10) {
        PRINT("Invalid mixtape slot!\n");
        return 1;
    }
    p_tape = &boombox->tapes[to_eject]; // -0x10 bytes, for some reason?
    if(i == boombox->tapes[to_eject]) {
        PRINT("No mixtape to eject from this slot!\n");
        return 1;
    }
    if(to_eject == boombox->current_tape) {
        boombox->current_tape = -1;
        boombox->current_track = zero;
        boombox->current_position = zero;
    }
    tape = *p_tape; // +0x10 bytes
    if(tape->num_tracks > zero) {
        p_track = &tape->tracks[0];
        i = zero;
        do {
            free(*p_track);
            i++;
            p_track++;
        } while(i < tape->num_tracks);
    }
    free(tape);
    *p_tape = zero;
    PRINT("Mixtape ejected!\n");
    return 0;
}

int seek(struct boombox_t* boombox) {
    // boombox in %rbx
    int i = boombox->current_tape; // %rax
    struct tape_t *cur_tape; // %rcx
    struct track_t *cur_track; // %rsi
    int seek_offset; // rsp+0x30, %rdi
    if(i != -1 && (cur_tape = boombox->tapes[i])) {
        if((i = boombox->current_track) <= cur_tape->num_tracks) {
            cur_track = cur_tape->tracks[i];
            PRINT("How far would you like to seek into the track? ");
            scanf("%llu", &seek_offset);
            NEWLINE;
            if(cur_track->length < seek_offset) {
                PRINT("Requested seek is larger than the track!\n");
                return 1;
            }
            PRINT("Seek successful!\n");
            boombox->current_position = seek_offset;
            return 0;
        } else {
            PRINT("You must select a track to seek through it...\n");
            return 1;
        } 
    } else {
        PRINT("You must select a mixtape to seek...\n");
        return 1;
    }
}

int select_mixtape(struct boombox_t* boombox) {
    // boombox in %rbx
    int i; // rsp+0x38, %edx
    show_tapes(boombox);
    PRINT("Which mixtape do you want to switch to? ");
    scanf("%llu", &i);
    NEWLINE;
    i--;
    if(i >= 10) {
        PRINT("Invalid mixtape slot!\n");
        return 1;
    }
    if(!boombox->tapes[i]) {
        PRINT("There's no mixtape in that slot!\n");
        return 1;
    }
    boombox->current_tape = i;
    boombox->current_track = 0;
    boombox->current_position = 0;
    PRINT("Switched to new mixtape slot!\n");
    return 0;
}

void print_menu() {
    PRINT("+----------------------+\n");
    PRINT("| 1. upload mixtape    |\n");
    PRINT("| 2. eject mixtape     |\n");
    PRINT("| 3. select mixtape    |\n");
    PRINT("| 4. play              |\n");
    PRINT("| 5. fast forward      |\n");
    PRINT("| 6. rewind            |\n");
    PRINT("| 7. next track        |\n");
    PRINT("| 8. previous track    |\n");
    PRINT("| 9. record            |\n");
    PRINT("| 10. seek             |\n");
    PRINT("| 11. print menu       |\n");
    PRINT("| 12. exit             |\n");
    PRINT("+----------------------+\n");
}

void play(struct boombox_t* boombox) {
    // boombox in %rbx
    char buf[0x80]; // rsp+0x20
    int i; // %rax
    struct tape_t* tape; // %rcx
    struct track_t* track; // %rdi
    int ticks; // %rsi
    // buf is initialized with a movb and a memset for 0x7f
    memset(buf, 0, 0x80);
    if((i = boombox->current_tape) == -1 && (tape = boombox->tapes[i])) {
        if((i = boombox->current_track) > tape->num_tracks) {
            PRINT("You must select a track before you can play music...\n");
            return; // and check cookie
        }
        track = tape->tracks[i];
        i = track->length;
        // note ==, not <=
        if(boombox->current_position == i) {
            PRINT("End of track! Nothing to play.");
            return; // and check cookie
        }
        ticks = GetTickCount();
        render_music(
            &track->data[boombox->current_position],
            track->length - boombox->current_position - 1,
            buf);
        print_with_notes(buf);
        PRINT("Press enter to stop listening to music...");
        NEWLINE;
        // searching for 0x10624dd3 gives http://zormness.blogspot.com/2005/08/optimized-division-through.html
        // which talks about how that constant can be used to divide by 1000 without issuing an x86 `div` instruction (historically slow)
        // the blogpost's contents are included in a comment below this function
        boombox->current_position += (GetTickCount() - ticks) / 1000;
        if(boombox->current_position < track->length) {
            PRINT("Music paused!\n");
            return; // and check cookie
        } else {
            PRINT("Reached end of track\n");
            boombox->current_position = track->length;
            return; // and check cookie
        }
    } else {
        PRINT("You must select a mixtape before you can play music...\n"):
        // there seems to be a stack cookie check here
        return;
    }
}
/*
Optimized division through multiplication

   Division is inheritly slow on most computer processes. As such when
   compiling source code that contains division a compiler may optimize it
   through the use of multiplication. This poses a nuisance when trying to
   reverse engineer code.
   You may run across something that looks like this:
.text:6F3709B5                 mov     eax, 10624DD3h
.text:6F3709BA                 mul     ecx
.text:6F3709BC                 mov     eax, [edi+0FFCh]
.text:6F3709C2                 shr     edx, 6

   Despite the fact that this uses mul(multiply) it is really performing a
   divide. To figure out what the orginal code was dividing by one has to
   look at the shift right.
.text:6F3709C2                 shr     edx, 6

   Because edx is the high 32bits of the resulting multiplication it is
   really using 38bits. So we get 1 << 38 which plugged into calc.exe is
   100000000000000000000000000000000000000 in binary or 4000000000 in hex.
   Now we have to look at the mov eax, 10624DD3h line. It provides the
   other key number we need. Because this is division we take 0x4000000000
   and divide it by 0x10624DD3.
   0x4000000000 / 0x10624DD3 = 0x3E7 or 999 in decimal.
   Now its important to note that this is just an estimate and so its
   likely that the orginal code used 1000 instead of 999.
   The orginal C/C++ code likely looked something like this:
someVar1 = someVar2 / 1000;
*/

int record(struct boombox_t* boombox) {
    // boombox in %rbx
    // stack cookie at rsp+0x820
    char buf[0x800]; // rsp+0x20
    struct tape_t* tape;
    struct track_t* track;
    int track_length; // %rdi
    char *p; // %rsi
    int i;
    if(boombox->current_tape == -1 || !(tape = boombox->tapes[boombox->current_tape])) {
        PRINT("You must select a mixtape to record to...\n");
        return 1; // and check cookie
    }
    // unless I translated the assembly wrong, this is an off-by-1 bug
    if(boombox->current_track > tape->num_tracks) {
        PRINT("You must select a track to record over...\n");
        return 1;
    }
    track = tape->tracks[boombox->current_track];
    track_length = track->length - boombox->current_position;
    p = boombox->current_position + (char*)track; // track->data = 0x28+(char*)track;
    PRINT("Starting recording...\n");
    memset(buf, 0, 0x800);
    fgets(buf, 0x800, __iob_func());
    for(i=0; i<0x800; i++) {
        if(buf[i] == '\n') goto skip_newline;
    }
    NEWLINE;
    skip_newline:
    buf[i] = 0;
    // TODO: double-check int-width of track_length/record_aux parameter
    boombox->current_position += record_aux(buf, p+0x28 /*&track->data[boombox->current_position]*/, track_length);
    PRINT("Recorded to track!\n");
    return 0; // and check cookie
}

int record_aux(char* src, char* dst, unsigned int length) {
    // dst is passed in rdx, immediately spilled to rsp+0x10, then 5 registers are pushed, then 0x30 bytes are subtracted from rsp
    // this puts dst at rsp+0x68 (0x30 + 5*0x8 + 0x10), where it is later loaded into rax
    // src in %r13
    int input_length = -1; // %rbp
    int i; // %rbx
    int j = 0; // %esi
    int k = 0; // %r14
    int l; // %edi
    char c = 1; // %r12
    /*while(src[++input_length] != 0);
    if(input_length == 0) {
        return 0; // no stack cookie
    }*/
    if((input_length = strlen(src)) == 0) { return 0; }
    do {
        if(j >= length) {
            return 0;
        }
        for(l = 0; l < 0x10; l++, i=1) {
            if(!strncmp(music_notes[l],&buf[k], (i = strlen(music_notes[l])))) {
                // dst is loaded into rax from rsp+0x68
                if(c == 0) {
                    dst[j] |= l;
                    j++;
                } else {
                    dst[j] = l << 4;
                }
                c = !c;
            }
            k += i;
        }
    } while(k < input_length);
    return j;
}

/*
[0x1400064b0]> psz @ `pv`; s+ 8
beep
[0x1400064b8]> psz @ `pv`; s+ 8
bop
[0x1400064c0]> psz @ `pv`; s+ 8
zip
[0x1400064c8]> psz @ `pv`; s+ 8
zam
[0x1400064d0]> psz @ `pv`; s+ 8
flim
[0x1400064d8]> psz @ `pv`; s+ 8
flam
[0x1400064e0]> psz @ `pv`; s+ 8
ity
[0x1400064e8]> psz @ `pv`; s+ 8
bad
[0x1400064f0]> psz @ `pv`; s+ 8
do
[0x1400064f8]> psz @ `pv`; s+ 8
dub
[0x140006500]> psz @ `pv`; s+ 8
da
[0x140006508]> psz @ `pv`; s+ 8
bez
[0x140006510]> psz @ `pv`; s+ 8
um
[0x140006518]> psz @ `pv`; s+ 8
yo
[0x140006520]> psz @ `pv`; s+ 8
wop
[0x140006528]> psz @ `pv`; s+ 8
bap
[0x140006530]> psz @ `pv`; s+ 8
mode.$
*/

char* music_notes[] = {
    "beep", "bop", "zip", "zam",
    "flim", "flam", "ity", "bad",
    "do", "dub", "da", "bez",
    "um", "yo", "wop", "bap"
    };

int fast_forward(struct boombox_t* boombox) {
    // boombox in %rbx
    struct tape_t* tape;
    struct track_t* track;
    int i;
    int ticks; // %r9
    if((i = boombox->current_tape) == -1 || !(tape = boombox->tapes[i])) {
        PRINT("You must select a mixtape before you can fast forward music...\n");
        return 1;
    }
    if((i = boombox->current_track) > tape->num_tracks) {
        PRINT("You must select a track before you can fast forward music...\n");
        return 1;
    }
    if(boombox->current_position == (track = tape->tracks[i])->length) {
        PRINT("End of track! Can't fast forward\n");
        return 0;
    }
    ticks = GetTickCount();
    PRINT("Press enter to stop fast forwarding...");
    NEWLINE;
    ticks = GetTickCount() - ticks;
    /*
    >>> f = lambda x: 4*(x/1000)
    >>> g = lambda x: (4*x)/1000
    >>> f(1500)
    4
    >>> g(1500)
    6
    */
    if(4*(ticks/1000) == 0) { return 0; }
    i = boombox->current_position + 4*(ticks/1000);
    if(i < track->length) {
        boombox->current_position += (4*ticks)/1000;
        PRINT("Rewind stopped!\n");
        return 0;
    } else {
        boombox->current_position = track->length;
        PRINT("Reached end of track\n");
        return 0;
    }
}

int rewind(struct boombox_t* boombox) {
    struct tape_t* tape;
    struct track_t* track;
    int i;
    int ticks;
    if((i = boombox->current_tape) == -1 || !(tape = boombox->tapes[i])) {
        PRINT("You must select a mixtape before you can rewind music...\n");
        return 1;
    }
    if((i = boombox->current_track) > tape->num_tracks) {
        PRINT("You must select a track before you can rewind music...\n");  
        return 1;
    }
    if(boombox->current_position == 0) {
        PRINT("Start of track! Can't rewind\n");
        return 0;
    }
    ticks = GetTickCount();
    PRINT("Press enter to stop the rewind...");
    NEWLINE;
    ticks = 4 * ((GetTickCount() - ticks) / 1000);
    if(ticks == 0) { return 0; }
    // this uses the jns instruction, and I'm not sure I translated it correctly
    if(boombox->current_position - ticks < 0) {
        boombox->current_position = 0;
        PRINT("Reached start of track\n");
        return 0;
    } else {
        boombox->current_position -= ticks;
        PRINT("Rewind stopped!\n");
        return 0;
    }
}

int next_track(struct boombox_t* boombox) {
    struct tape_t* tape;
    struct track_t* track;
    int i;
    if((i = boombox->current_tape) == -1 || !(tape = boombox->tapes[i])) {
        PRINT("You must select a track before you can skip tracks...\n");
        return 1;
    }
    if(boombox->current_track+1 >= tape->num_tracks) {
        PRINT("Last track on mixtape - cannot skip!\n");
        return 1;
    }
    boombox->current_track++;
    boombox->current_position = 0;
    PRINT("Skipped forward!\n");
    return 0;
}

void render_music(char* src, int src_length, char* dst) {
    // src in %r15
    // src_length in %r14
    // dst in %rbx
    int i; // %rbp
    int j;
    char* tmp; // %rdx
    if(!src) { return strlen(dst); }
    for(i=0; i < src_length; i++, buf[0x7f] = 0) {
        j = src[i] >> 4;
        tmp = j < 0x10 ? music_notes[j] : "~ST4T!C~";
        strncat(dst, tmp, 0x7f - strlen(dst));
        j = src[i] & 0x0f;
        tmp = j < 0x10 ? music_notes[j] : "~ST4T!C~";
        strncat(dst, tmp, 0x7f - strlen(dst));
    }
    return strlen(dst);
}

int previous_track(struct boombox_t* boombox) {
    struct tape_t* tape;
    struct track_t* track;
    int i;
    if((i = boombox->current_tape) == -1 || !(tape = boombox->tapes[i])) {
        PRINT("You must select a mixtape before you skip tracks...\n");
        return 1;
    }
    if(boombox->current_track > tape->num_tracks) {
        PRINT("You must select a track before you can skip tracks...\n");
        return 1;
    }
    if(boombox->current_track == 0) {
        PRINT("First track on mixtape - cannot skip backwards!\n");
        return 1;
    }
    boombox->current_track--;
    boombox->current_position = 0;
    PRINT("Skipped backwards!\n");
    return 0;
}

