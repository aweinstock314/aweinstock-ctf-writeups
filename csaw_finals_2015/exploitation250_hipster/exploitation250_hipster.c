#include <stdio.h>
#include <string.h>

// 0x804b8f0
uint32_t someglobal;
// 0x804b8ac
uint32_t stackcount = 0;
// 0x804b8b0
char global_buf[0x40];

char *intro =
    "Sieg Heil!\n" \
    "Welcome to Hipster Hitler's Pocket Calculator!\n" \
    "My computing resources await you, mein F\xc3\xbchrer.\n" \
    "We now use Reverse Polish Notation as a result of our recent conquest of Poland.\n" \
    "All commands are prefixed with ':'.\n" \
    "Type :help for a list of commands.\n";

char *help =
    "His Excellency's available commands:" \
    "top  => Display top value of the currently selected stack." \
    "new  => Create a new stack and switch to it." \
    "del  => Delete currently selected stack." \
    "disp => Display all values on stack." \
    "next => Switch between active stacks." \
    "quit => Exit the calculator.";

// 0x08049e50
void writestr(int fd, char* s) {
    size_t len = strlen(s);
    // very obfuscated subroutine with many args, seems to just call write (not extensively verified)
    obfuscated_write(fd, s, len);
}

// 0x08049450
void print_intro() {
    writestr(1, intro);
}

// 0x08049db0
ssize_t getinput(int fd, void* buf, size_t size) {
    // again, heavily obfuscated, not going to verify, but it looks like a read wrapper
    return read(fd, buf, size);
}

// sizeof(struct stack_t) = 0xa8
struct stack_t {
    uint32_t cookie;
    int32_t* stackptr;
    int32_t items[40];
};


// 0x08048af0
void cmd_top() {
    if(stackcount > 0) {
        snprintf(global_buf, 0x40, "%d" // some kind of linked list ish stuff on a global
    } else  {
        writestr(1, "There are no active stacks, mein F\xc3\xbchrer.\n");
    }
}
// 0x08048cf0
void cmd_new() {
    struct stack_t *newstack;
    if(stackcount < 8) {
        newstack = malloc(sizeof(struct stack));
        if(newstack == 0) {
            writestr(1, "Failed to create stack, your Excellency!\nPlease have mercy!!!\n");
            return;
        }
        // TODO: inserting newstack into globals
    }
}
// 0x08048e60
void cmd_del() {}
// 0x08048b90
void cmd_disp() {}
// 0x08048ff0
void cmd_next() {}
// 0x080490b0
void cmd_help() {
    writestr(1, help);
}

// 0x080490e0
int handle_command(char* buf) {
    if(!strcmp(buf, "top")) { cmd_top(); }
    else if(!strcpy(buf, "new")) { cmd_new(); }
    else if(!strcpy(buf, "del")) { cmd_del(); }
    else if(!strcpy(buf, "disp")) { cmd_disp(); }
    else if(!strcpy(buf, "next")) { cmd_next(); }
    else if(!strcpy(buf, "quit")) { return 1; }
    else if(!strcpy(buf, "help")) { cmd_help(); }
    else {
        writestr(1, "That command is not yet implemented, mein F\xc3\xbchrer!\nPlease do not feed me to the dogs!\n");
        return -1;
    }
    return 0;
}

// 0x08049280
int handle_op(char* buf) {
    // TODO: reversing
}

int main(int argc, char** argv) {
    // {argc,argv} are at ebp+{8,c}, and copied into ebp-{c,10} for locals
    char input_buf[0x10]; // ebp-0x20
    uint32_t var24, var28, var2c, var30, var34, var38, var3c, var40, var44, var48, var4c;
    // int setvbuf(FILE *stream, char *buf, int mode, size_t size);
    var30 = setvbuf(stdout, 0, 2, 0);
    var34 = 0;
    srand(time(0));
    print_intro();
    someglobal = rand();
    while(1) {
        var38 = 1;
        writestr(1, "==> ");
        var24 = getinput(0, input_buf, 0xf);
        if(input_buf[0] == ':') {
            if(handle_command(&input_buf[1]) == 1) { break; }
            else { continue; }
        }
        if(var24 >= 1) {
            if(handle_op(&input_buf[0]) == 5) { break; }
            else { continue; }
        }
    }
    var48 = 1;
    var4c = writestr(1, "Farewall, mein F\xc3\xbchrer!\nHave a good time in France!\n");
    return 0;
}
